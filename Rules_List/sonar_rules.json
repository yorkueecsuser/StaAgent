[
    {
        "id": 1,
        "title": "Return values should not be ignored when they contain the operation status code",
        "description": "When the return value of a function call contains the operation status code, this value should be tested to make sure the operation completed\nsuccessfully.\nThis rule raises an issue when the return values of the following are ignored:\njava.io.File operations that return a status code (except mkdirs ) Iterator.hasNext() Enumeration.hasMoreElements() Lock.tryLock() non-void Condition.await* methods CountDownLatch.await(long, TimeUnit) Semaphore.tryAcquire BlockingQueue : offer , remove\njava.io.File operations that return a status code (except mkdirs )\nIterator.hasNext()\nEnumeration.hasMoreElements()\nLock.tryLock()\nnon-void Condition.await* methods\nCountDownLatch.await(long, TimeUnit)\nSemaphore.tryAcquire\nBlockingQueue : offer , remove\nNoncompliant code example\npublic void doSomething(File file, Lock lock) {\n  file.delete();  // Noncompliant\n  // ...\n  lock.tryLock(); // Noncompliant\n}\nCompliant solution\npublic void doSomething(File file, Lock lock) {\n  if (!lock.tryLock()) {\n    // lock failed; take appropriate action\n  }\n  if (!file.delete()) {\n    // file delete failed; take appropriate action\n  }\n}"
    },
    {
        "id": 2,
        "title": "Consumed Stream pipelines should not be reused",
        "description": "Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines. A stream should be operated on\n(invoking an intermediate or terminal stream operation) only once.\nNoncompliant code example\nStream<Widget> pipeline = widgets.stream().filter(b -> b.getColor() == Color.RED);\nvar res1 = pipeline.findAny();\nvar res2 = pipeline.mapToInt(b -> b.getWeight()).sum(); // Noncompliant"
    },
    {
        "id": 3,
        "title": "\"String.indexOf\" should be used with correct ranges",
        "description": "Java 21 adds new String.indexOf methods that accept ranges ( beginIndex , to endIndex ) rather than just a\nstart index. A StringIndexOutOfBounds can be thrown when indicating an invalid range, namely when:\nbeginIndex > endIndex (eg: beginIndex and endIndex arguments are mistakenly reversed) beginIndex < 0 (eg: because the older String.indexOf(what, fromIndex) accepts negative values)\nbeginIndex > endIndex (eg: beginIndex and endIndex arguments are mistakenly reversed)\nbeginIndex < 0 (eg: because the older String.indexOf(what, fromIndex) accepts negative values)"
    },
    {
        "id": 4,
        "title": "\"Math.clamp\" should be used with correct ranges",
        "description": "Java 21 introduces the new method Math.clamp(value, min, max) that fits a value within a specified interval. Before Java 21, this\nbehavior required explicit calls to the Math.min and Math.max methods, as in Math.min(max, Math.max(value,\nmin)) .\nIf min > max , Math.clamp throws an IllegalArgumentException , indicating an invalid interval. This can\noccur if the min and max arguments are mistakenly reversed.\nNote that Math.clamp is not a general substitute for Math.min or Math.max , but for the combination of both.\nIf value is the same as min or max , using Math.clamp is unnecessary and Math.min or Math.max should be used instead."
    },
    {
        "id": 5,
        "title": "Virtual threads should not run tasks that include synchronized code",
        "description": "Java 21 virtual threads allow the JVM to optimize the usage of OS threads, by mounting and unmounting them on an OS thread when needed, and making\nthem more efficient when dealing with blocking operations such as HTTP requests or I/O.\nHowever, when code is executed inside a synchronized block or synchronized method, the virtual thread stays pinned to the\nunderlying OS thread and cannot be unmounted during a blocking operation. This will cause the OS thread to be blocked, which can impact the\nscalability of the application.\nTherefore, virtual threads should not execute code that contains synchronized blocks or invokes synchronized methods.\nPlatform threads should be used in these cases.\nThis rule raises an issue when a virtual thread contains synchronized blocks or invokes synchronized methods.\nCode examples\nvoid enqueue(){\n    Thread.startVirtualThread(() -> { // Noncompliant; use a platform thread instead\n            setupOperations();\n            dequeLogic();\n        }\n    });\n}\nvoid enqueue(){\n    new Thread(() -> {\n        synchronized {\n            setupOperations();\n            dequeLogic();\n        }\n    }).start();\n}\nvoid enqueue2(){\n    Thread.startVirtualThread(() -> { // Noncompliant; use a platform thread instead of a virtual one\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    });\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}\nvoid enqueue2(){\n    new Thread(() -> {\n        if(someCondition){\n            synchronizedMethod();\n        }else{\n            defaultLogic();\n        }\n    }).start();\n}\nsynchronized void synchronizedMethod(){}\nvoid defaultLogic(){}"
    },
    {
        "id": 6,
        "title": "\"setDaemon\", \"setPriority\" and \"getThreadGroup\" should not be invoked on virtual threads",
        "description": "The Thread class has some methods that are used to monitor and manage its execution. With the introduction of virtual threads in Java\n21, there are three of these methods that behave differently between the standard platform threads and the virtual ones.\nFor virtual threads:\nThread.setDaemon(boolean) will throw an IllegalArgumentException if false is passed as an argument as a\n  virtual thread daemon status is always true. Thread.setPriority(int priority) will never change the actual priority of a virtual thread, which is always equal to Thread.NORM_PRIORITY Thread.getThreadGroup() will return a dummy \"VirtualThreads\" group that is empty and should not be used\nThread.setDaemon(boolean) will throw an IllegalArgumentException if false is passed as an argument as a\n  virtual thread daemon status is always true.\nThread.setPriority(int priority) will never change the actual priority of a virtual thread, which is always equal to Thread.NORM_PRIORITY\nThread.getThreadGroup() will return a dummy \"VirtualThreads\" group that is empty and should not be used\nThis rule reports an issue when one of these methods is invoked on a virtual thread.\nCode examples\nThread t = Thread.ofVirtual().unstarted(()->{/* some task */});\nt.setPriority(1); // Noncompliant; virtual threads' priority cannot be changed\nt.setDaemon(false); // Noncompliant; will throw IllegalArgumentException\nt.setDaemon(true); // Noncompliant; redundant\nt.start();\nvar threadGroup = t.getThreadGroup(); // Noncompliant; virtual thread groups should not be used"
    },
    {
        "id": 7,
        "title": "Virtual threads should be used for tasks that include heavy blocking operations",
        "description": "Whenever a virtual thread is started, the JVM will mount it on an OS thread. As soon as the virtual thread runs into a blocking operation like an\nHTTP request or a filesystem read/write operation, the JVM will detect this and unmount the virtual thread. This allows another virtual thread to take\nover the OS thread and continue its execution.\nThis is why virtual threads should be preferred to platform threads for tasks that involve blocking operations. By default, a Java thread is a\nplatform thread. To use a virtual thread it must be started either with Thread.startVirtualThread(Runnable) or Thread.ofVirtual().start(Runnable) .\nThis rule raises an issue when a platform thread is created with a task that includes heavy blocking operations."
    },
    {
        "id": 8,
        "title": "Set appropriate Status Codes on HTTP responses",
        "description": "The request handler function in a Controller should set the appropriate HTTP status code based on the operation\u2019s success or failure.\nThis is done by returning a Response object with the appropriate status code.\nIf an exception is thrown during the execution of the handler, the status code should be in the range of 4xx or 5xx. Examples of such codes are BAD_REQUEST , UNAUTHORIZED , FORBIDDEN , NOT_FOUND , INTERNAL_SERVER_ERROR , BAD_GATEWAY , SERVICE_UNAVAILABLE , etc.\nThe status code should be 1xx, 2xx, or 3xx if no exception is thrown and the operation is considered successful. Such codes include OK , CREATED , MOVED_PERMANENTLY , FOUND , etc."
    },
    {
        "id": 9,
        "title": "Beans in \"@Configuration\" class should have different names",
        "description": "Naming conventions play a crucial role in maintaining code clarity and readability. The uniqueness of bean names in Spring configurations is vital\nto the clarity and readability of the code. When two beans share the same name within a configuration, it is not obvious to the reader which bean is\nbeing referred to. This leads to potential misunderstandings and errors."
    },
    {
        "id": 10,
        "title": "SpEL expression should have a valid syntax",
        "description": "SpEL is used in Spring annotations and is parsed by the Spring framework, not by the Java compiler. This means that invalid SpEL expressions are\nnot detected during Java compile time. They will cause exceptions during runtime instead, or even fail silently with the expression string interpreted\nas a simple string literal by Spring.\nExceptions\nThis rule does report syntactical errors in SpEL expressions but does not consider semantic errors, such as unknown identifiers or incompatible\noperand data types."
    },
    {
        "id": 11,
        "title": "\"@PathVariable\" annotation should be present if a path variable is used",
        "description": "The @PathVariable annotation in Spring extracts values from the URI path and binds them to method parameters in a Spring MVC\ncontroller. It is commonly used with @GetMapping , @PostMapping , @PutMapping , and @DeleteMapping to\ncapture path variables from the URI. These annotations map HTTP requests to specific handler methods in a controller. They are part of the Spring Web\nmodule and are commonly used to define the routes for different HTTP operations in a RESTful API.\nIf a method has a path template containing a placeholder, like \"/api/resource/{id}\", and there\u2019s no @PathVariable annotation on a\nmethod parameter to capture the id path variable, Spring will disregard the id variable."
    },
    {
        "id": 12,
        "title": "\"@Bean\" methods for Singleton should not be invoked in \"@Configuration\" when proxyBeanMethods is false",
        "description": "When setting the proxyBeanMethods attribute to false the @Bean methods are not proxied and this is similar\nto removing the @Configuration stereotype. In this scenario, @Bean methods within the @Configuration annotated\nclass operate in lite\nmode , resulting in a new bean creation each time the method is invoked.\nFor Singleton beans, this could cause unexpected outcomes as the bean is created multiple times instead of being created once and\ncached.\nThe rule raises an issue when the proxyBeanMethods attribute is set to false and the @Bean method of a Singleton bean is directly invoked in the @Configuration annotated class code."
    },
    {
        "id": 13,
        "title": "\"@Qualifier\" should not be used on \"@Bean\" methods",
        "description": "In Spring Framework, the @Qualifier annotation is typically used to disambiguate between multiple beans of the same type when\nauto-wiring dependencies. It is not necessary to use @Qualifier when defining a bean using the @Bean annotation because the\nbean\u2019s name can be explicitly specified using the name attribute or derived from the method name. Using @Qualifier on @Bean methods can lead to confusion and redundancy. Beans should be named appropriately using either the name attribute of\nthe @Bean annotation or the method name itself.\nNoncompliant code example\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  @Qualifier(\"myService\")\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean\n  @Qualifier(\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}\nCompliant solution\n@Configuration\npublic class MyConfiguration {\n  @Bean\n  public MyService myService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"betterService\")\n  public MyService aBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"evenBetterService\")\n  public MyService anEvenBetterService() {\n    // ...\n    return new MyService();\n  }\n\n  @Bean(name=\"differentService\")\n  public MyBean aDifferentService() {\n    // ...\n    return new MyBean();\n  }\n}"
    },
    {
        "id": 14,
        "title": "\"@Autowired\" should only be used on a single constructor",
        "description": "@Autowired is an annotation in the Spring Framework for automatic dependency injection. It tells Spring to automatically provide the\nrequired dependencies (such as other beans or components) to a class\u2019s fields, methods, or constructors, allowing for easier and more flexible\nmanagement of dependencies in a Spring application. In other words, it\u2019s a way to wire up and inject dependencies into Spring components\nautomatically, reducing the need for manual configuration and enhancing modularity and maintainability.\nIn any bean class, only one constructor is permitted to declare @Autowired with the required attribute set to true. This\nsignifies the constructor to be automatically wired when used as a Spring bean. Consequently, when the required attribute remains at its default value\n(true), only a singular constructor can bear the @Autowired annotation. In cases where multiple constructors have this annotation, they\nmust all specify required=false to be eligible as candidates for auto-wiring."
    },
    {
        "id": 15,
        "title": "Use of the \"@Async\" annotation on methods declared within a \"@Configuration\" class in Spring Boot",
        "description": "@Configuration is a class-level annotation indicating that an object is a source of bean definitions. @Configuration classes declare beans through @Bean -annotated methods. Calls to @Bean methods on @Configuration classes can\nalso be used to define inter-bean dependencies. The @Bean annotation indicates that a method instantiates, configures, and initializes a\nnew object to be managed by the Spring IoC container.\nAnnotating a method of a bean with @Async will make it execute in a separate thread. In other words, the caller will not wait for the\ncompletion of the called method.\nThe @Async annotation is not supported on methods declared within a @Configuration class. This is because @Async methods are typically used for asynchronous processing, and they require certain infrastructure to be set up, which may not be\navailable or appropriate in a @Configuration class."
    },
    {
        "id": 16,
        "title": "Nullable injected fields and parameters should provide a default value",
        "description": "The @Value annotation does not guarantee that the property is defined. Particularly if a field or parameter is annotated as nullable,\nit indicates that the developer assumes that the property may be undefined.\nAn undefined property may lead to runtime exceptions when the Spring framework tries to inject the autowired dependency during bean creation.\nThis rule raises an issue when a nullable field or parameter is annotated with @Value and no default value is provided."
    },
    {
        "id": 17,
        "title": "Async methods should return void or Future",
        "description": "The Spring framework provides the annotation Async to mark a method (or all methods of a type) as a candidate for asynchronous\nexecution.\nAsynchronous methods do not necessarily, by their nature, return the result of their calculation immediately. Hence, it is unexpected and in clear\nbreach of the Async contract for such methods to have a return type that is neither void nor a Future type."
    },
    {
        "id": 18,
        "title": "Model attributes should follow the Java identifier naming convention",
        "description": "Spring Expression Language (SpEL) is an expression language used in the Spring Framework for evaluating and manipulating objects, properties, and\nconditions within Spring-based applications.\norg.springframework.ui.Model is an interface in the Spring Framework that represents a container for data that can be passed between a\ncontroller and a view in a Spring MVC web application, allowing for data sharing during the request-response cycle.\nAttributes added to the org.springframework.ui.Model should follow the Java identifier naming convention, which means they must start\nwith a letter a-z, A-Z , underscore _ , or a dollar sign $ and may be followed by letters, digits, underscores,\nor dollar signs.\nFailure to do so may result in SpEL parsing errors when using these attributes in template engines."
    },
    {
        "id": 19,
        "title": "Accessing an array element should not trigger an ArrayIndexOutOfBoundsException",
        "description": "An array index out-of-bounds exception indicates a bug or a logical error in the code.\nIn Java, arrays have a fixed size, and their elements are indexed starting from 0 , counting up to the last index that is still smaller\nthan the size. When trying to access an array outside of this range, an ArrayIndexOutOfBoundsException will be thrown and the operation\nwill fail.\nWhat is the potential impact?\nIssues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss.\nIf the computation of an index value is tied to user input data, this issue can potentially even be exploited by attackers to disrupt your\napplication."
    },
    {
        "id": 20,
        "title": "Collections should not be modified while they are iterated",
        "description": "Iterating over a collection using a for-each loop in Java relies on iterators.\nAn iterator is an object that allows you to traverse a collection of elements, such as a list or a dictionary. Iterators are used in for-each loops to iterate over the elements of a collection one at a time.\nIt is important to note that iterators are designed to be read-only. Modifying a collection while iterating over it can cause unexpected behavior,\nas the iterator may skip over or repeat elements. Therefore, it is important to avoid modifying a collection while iterating over it to ensure that\nyour code behaves as expected.\nMost JDK collection implementations don\u2019t support such modification and may throw a ConcurrentModificationException . Even if no such\nexception is thrown, attempting to modify a collection during iteration could be the source of incorrect or unspecified behaviors in the code.\nIf you still want to modify the collection, it is best to refactor the code and use a second collection (e.g by using streams and filter\noperations).\nCode examples\npublic static void foo(List<String> lst) {\n    for (String element : lst) {\n      if (element.startsWith(\"x\")) {\n        lst.remove(element); // Noncompliant: lst size has been modified by \"remove\" call while it's iterated.\n      }\n    }\n  }\npublic static void foo(List<String> lst) {\n    List<String> toRemove = new ArrayList<>();\n    for (String element : lst) {\n      if (element.startsWith(\"x\")) {\n        toRemove.add(element);\n      }\n    }\n    lst.removeAll(toRemove);\n  }"
    },
    {
        "id": 21,
        "title": "Calls to methods should not trigger an exception",
        "description": "It is common for methods to check the value of their parameters or the state of their associated object and throw an exception when one of them\ndoes not match a given condition. Those conditions are usually mentioned in the javadoc of the method.\nThis rule raises an issue when it detects that a method call will trigger one of the following exceptions:\njava.lang.IllegalArgumentException java.lang.IllegalStateException\njava.lang.IllegalArgumentException\njava.lang.IllegalStateException\nWhat is the potential impact?\nIssues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss."
    },
    {
        "id": 22,
        "title": "Unsupported methods should not be called on some collection implementations",
        "description": "The Java Collections framework defines interfaces such as java.util.List or java.util.Map . Several implementation classes\nare provided for each of those interfaces to fill different needs: some of the implementations guarantee a few given performance characteristics, some\nothers ensure a given behavior, for example immutability.\nAmong the methods defined by the interfaces of the Collections framework, some are declared as \"optional\": an implementation class may choose to\nthrow an UnsupportedOperationException when one of those methods is called. For example, java.util.Collections.emptyList() returns an implementation of java.util.List which is documented as \"immutable\". Calling the add method on this object\ntriggers an UnsupportedOperationException .\nWhat is the potential impact?\nIssues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss."
    },
    {
        "id": 23,
        "title": "Cast operations should not trigger a ClassCastException",
        "description": "A cast operation allows an object to be \"converted\" from one type to another. The compiler raises an error if it can determine that the target type\nis incompatible with the declared type of the object, otherwise it accepts the cast. However, depending on the actual runtime type of the object, a\ncast operation may fail at runtime. When a cast operation fails, a ClassCastException is thrown.\nWhat is the potential impact?\nThis type of exception is usually unexpected. It causes the program to crash or puts it into an inconsistent state. Therefore, this issue might\nimpact the availability and reliability of your application, or even result in data loss."
    },
    {
        "id": 24,
        "title": "Equals method should be overridden in records containing array fields",
        "description": "In records, the default behavior of the equals() method is to check the equality by field values. This works well for primitive fields\nor fields, whose type overrides equals() , but this behavior doesn\u2019t work as expected for array fields.\nBy default, array fields are compared by their reference, and overriding equals() is highly appreciated to achieve the deep equality\ncheck. The same strategy applies to hashCode() and toString() methods.\nThis rule reports an issue if a record class has an array field and is not overriding equals() , hashCode() or toString() methods.\nNoncompliant code example\nrecord Person(String[] names, int age) {} // Noncompliant\nCompliant solution\nrecord Person(String[] names, int age) {\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age && Arrays.equals(names, person.names);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = Objects.hash(age);\n        result = 31 * result + Arrays.hashCode(names);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"names=\" + Arrays.toString(names) +\n                \", age=\" + age +\n                '}';\n    }\n}"
    },
    {
        "id": 25,
        "title": "Reflection should not be used to increase accessibility of records' fields",
        "description": "In general, altering or bypassing the accessibility of classes, methods, or fields violates the encapsulation principle and could lead to runtime\nerrors. For records the case is even trickier: you cannot change the visibility of records\u2019s fields and trying to update the existing value will lead\nto IllegalAccessException at runtime.\nThis rule raises an issue when reflection is used to change the visibility of a record\u2019s field, and when it is used to directly update a record\u2019s\nfield value.\nNoncompliant code example\nrecord Person(String name, int age) {}\n\nPerson person = new Person(\"A\", 26);\nField field = Person.class.getDeclaredField(\"name\");\nfield.setAccessible(true); // secondary\nfield.set(person, \"B\"); // Noncompliant"
    },
    {
        "id": 26,
        "title": "Members ignored during record serialization should not be used",
        "description": "In Records, serialization is not done the same way as for ordinary serializable or externalizable classes. The serialized representation of a\nrecord object will be a sequence of values (record components). During the deserialization of records, the stream of components is read and components\nare constructed. Then the record object is recreated by invoking the record\u2019s canonical constructor with the component values serving as arguments (or\ndefault values for absent arguments).\nThis process cannot be customized, so any class-specific writeObject , readObject , readObjectNoData , writeExternal , and readExternal methods or serialPersistentFields fields in record classes are ignored during\nserialization and deserialization.\nHowever, there is a way to substitute serialized/deserialized objects in writeReplace and readResolve .\nThis rule raises an issue when any of writeObject , readObject , readObjectNoData , writeExternal , readExternal or serialPersistentFields are present as members in a Record class.\nNoncompliant code example\nrecord Record() implements Serializable {\n  @Serial\n  private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; // Noncompliant\n  @Serial\n  private void writeObject(ObjectOutputStream out) throws IOException { // Noncompliant\n    ...\n  }\n}\nrecord Record() implements Externalizable {\n  @Override\n  public void writeExternal(ObjectOutput out) throws IOException { // Noncompliant\n    ...\n  }\n  @Override\n  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { // Noncompliant\n    ...\n  }\n}\nCompliant solution\nrecord Record() implements Serializable {}\n\nrecord Record() implements Serializable {\n  private Object writeReplace() throws ObjectStreamException {\n    ...\n  }\n  private Object readResolve() throws ObjectStreamException {\n    ...\n  }\n}"
    },
    {
        "id": 27,
        "title": "Map \"computeIfAbsent()\" and \"computeIfPresent()\" should not be used to add \"null\" values.",
        "description": "Map computeIfAbsent and computeIfPresent methods are\nconvenient to avoid the cumbersome process to check if a key exists or not, followed by the addition of the entry. However, when the function used to\ncompute the value returns null , the entry key->null will not be added to the Map. Furthermore, in the case of computeIfPresent , if the key is present the entry will be removed. These methods should therefore not be used to conditionally add an\nentry with a null value. The traditional way should be used instead.\nThis rule raises an issue when computeIfAbsent or computeIfPresent is used with a lambda always returning null.\nNoncompliant code example\nmap.computeIfAbsent(key, k -> null); // Noncompliant, the map will not contain an entry key->null.\nmap.computeIfPresent(key, (k, oldValue) -> null); // Noncompliant\nCompliant solution\nif (!map.containsKey(key)) {\n    map.put(key, null);\n}\nif (map.containsKey(key)) {\n    map.put(key, null);\n}"
    },
    {
        "id": 28,
        "title": "AssertJ assertions with \"Consumer\" arguments should contain assertion inside consumers",
        "description": "AssertJ assertions taking Consumer objects as arguments are expected to contain \"requirements\", which should themselves be expressed\nas assertions. This concerns the following methods: allSatisfy , anySatisfy , hasOnlyOneElementSatisfying , isInstanceOfSatisfying , noneSatisfy , satisfies , satisfiesAnyOf , zipSatisfy .\nThese methods are assuming the Consumer will do the assertions itself. If you do not do any assertion in the Consumer , it probably means that you are inadvertently only partially testing your object.\nThis rule raises an issue when a Consumer argument of any of the above methods does not contain any assertion.\nNoncompliant code example\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -> \"Hello\".equals(s)); // Noncompliant - not testing the string value\nassertThat(myObject).satisfies(\"Hello\"::equals); // Noncompliant - not testing the string value\nCompliant solution\nassertThat(myObject).isInstanceOfSatisfying(String.class, s -> assertThat(s).isEqualTo(\"Hello\"));\nassertThat(myObject).satisfies(obj -> assertThat(obj).isEqualTo(\"Hello\"));"
    },
    {
        "id": 29,
        "title": "Mockito argument matchers should be used on all parameters",
        "description": "Mockito provides argument matchers and argument captors for flexibly stubbing or verifying method calls.\nMockito.verify() , Mockito.when() , Stubber.when() and BDDMockito.given() each have overloads\nwith and without argument matchers.\nHowever, if argument matchers or captors are used only on some of the parameters, all the parameters need to have matchers as well, otherwise an InvalidUseOfMatchersException will be thrown.\nThis rule consequently raises an issue every time matchers are not used on all the parameters of a stubbed/verified method."
    },
    {
        "id": 30,
        "title": "The regex escape sequence \\cX should only be used with characters in the @-_ range",
        "description": "In regular expressions the escape sequence \\cX , where the X stands for any character that\u2019s either @ , any capital ASCII\nletter, [ , \\ , ] , ^ or _ , represents the control character that \"corresponds\" to the\ncharacter following \\c , meaning the control character that comes 64 bytes before the given character in the ASCII encoding.\nIn some other regex engines (for example in that of Perl) this escape sequence is case insensitive and \\cd produces the same control\ncharacter as \\cD . Further using \\c with a character that\u2019s neither @ , any ASCII letter, [ , \\ , ] , ^ nor _ , will produce a warning or error in those engines. Neither of these things is true\nin Java, where the value of the character is always XORed with 64 without checking that this operation makes sense. Since this won\u2019t lead to a\nsensible result for characters that are outside of the @ to _ range, using \\c with such characters is almost\ncertainly a mistake.\nNoncompliant code example\nPattern.compile(\"\\\\ca\"); // Noncompliant, 'a' is not an upper case letter\nPattern.compile(\"\\\\c!\"); // Noncompliant, '!' is outside of the '@'-'_' range\nCompliant solution\nPattern.compile(\"\\\\cA\"); // Compliant, this will match the \"start of heading\" control character\nPattern.compile(\"\\\\c^\"); // Compliant, this will match the \"record separator\" control character"
    },
    {
        "id": 31,
        "title": "Regex lookahead assertions should not be contradictory",
        "description": "Lookahead assertions are a regex feature that makes it possible to look ahead in the input without consuming it. It is often used at the end of\nregular expressions to make sure that substrings only match when they are followed by a specific pattern.\nFor example, the following pattern will match an \"a\" only if it is directly followed by a \"b\". This does not consume the \"b\" in the process:\nPattern.compile(\"a(?=b)\");\nHowever, lookaheads can also be used in the middle (or at the beginning) of a regex. In that case there is the possibility that what comes after\nthe lookahead contradicts the pattern inside the lookahead. Since the lookahead does not consume input, this makes the lookahead impossible to match\nand is a sign that there\u2019s a mistake in the regular expression that should be fixed.\nCode examples\nPattern.compile(\"(?=a)b\"); // Noncompliant, the same character can't be equal to 'a' and 'b' at the same time\nPattern.compile(\"(?<=a)b\");\nPattern.compile(\"a(?=b)\");"
    },
    {
        "id": 32,
        "title": "Back references in regular expressions should only refer to capturing groups that are matched before the reference",
        "description": "When a back reference in a regex refers to a capturing group that hasn\u2019t been defined yet (or at all), it can never be matched. Named back\nreferences throw a PatternSyntaxException in that case; numeric back references fail silently when they can\u2019t match, simply making the\nmatch fail.\nWhen the group is defined before the back reference but on a different control path (like in (.)|\\1 for example), this also leads to a\nsituation where the back reference can never match.\nNoncompliant code example\nPattern.compile(\"\\\\1(.)\"); // Noncompliant, group 1 is defined after the back reference\nPattern.compile(\"(.)\\\\2\"); // Noncompliant, group 2 isn't defined at all\nPattern.compile(\"(.)|\\\\1\"); // Noncompliant, group 1 and the back reference are in different branches\nPattern.compile(\"(?<x>.)|\\\\k<x>\"); // Noncompliant, group x and the back reference are in different branches\nCompliant solution\nPattern.compile(\"(.)\\\\1\");\nPattern.compile(\"(?<x>.)\\\\k<x>\");"
    },
    {
        "id": 33,
        "title": "Regular expressions should not overflow the stack",
        "description": "The Java regex engine uses recursive method calls to implement backtracking. Therefore when a repetition inside a regular expression contains\nmultiple paths (i.e. the body of the repetition contains an alternation ( | ), an optional element or another repetition), trying to match\nthe regular expression can cause a stack overflow on large inputs. This does not happen when using a possessive quantifier (such as *+ instead of * ) or when using a character class inside a repetition (e.g. [ab]* instead of (a|b)* ).\nThe size of the input required to overflow the stack depends on various factors, including of course the stack size of the JVM. One thing that\nsignificantly increases the size of the input that can be processed is if each iteration of the repetition goes through a chain of multiple constant\ncharacters because such consecutive characters will be matched by the regex engine without invoking any recursion.\nFor example, on a JVM with a stack size of 1MB, the regex (?:a|b)* will overflow the stack after matching around 6000 characters\n(actual numbers may differ between JVM versions and even across multiple runs on the same JVM) whereas (?:abc|def)* can handle around\n15000 characters.\nSince often times stack growth can\u2019t easily be avoided, this rule will only report issues on regular expressions if they can cause a stack overflow\non realistically sized inputs. You can adjust the maxStackConsumptionFactor parameter to adjust this.\nNoncompliant code example\nPattern.compile(\"(a|b)*\"); // Noncompliant\nPattern.compile(\"(.|\\n)*\"); // Noncompliant\nPattern.compile(\"(ab?)*\"); // Noncompliant\nCompliant solution\nPattern.compile(\"[ab]*\"); // Character classes don't cause recursion the way that '|' does\nPattern.compile(\"(?s).*\"); // Enabling the (?s) flag makes '.' match line breaks, so '|\\n' isn't necessary\nPattern.compile(\"(ab?)*+\"); // Possessive quantifiers don't cause recursion because they disable backtracking"
    },
    {
        "id": 34,
        "title": "Regex boundaries should not be used in a way that can never be matched",
        "description": "In regular expressions the boundaries ^ and \\A can only match at the beginning of the input (or, in case of ^ in combination with the MULTILINE flag, the beginning of the line) and $ , \\Z and \\z only at the end.\nThese patterns can be misused, by accidentally switching ^ and $ for example, to create a pattern that can never\nmatch.\nNoncompliant code example\n// This can never match because $ and ^ have been switched around\nPattern.compile(\"$[a-z]+^\"); // Noncompliant\nCompliant solution\nPattern.compile(\"^[a-z]+$\");"
    },
    {
        "id": 35,
        "title": "Regex patterns following a possessive quantifier should not always fail",
        "description": "Possessive quantifiers in Regex patterns like below improve performance by eliminating needless backtracking:\n?+ , *+ , ++ , {n}+ , {n,}+ , {n,m}+\nBut because possessive quantifiers do not keep backtracking positions and never give back, the following sub-patterns should not match only similar\ncharacters. Otherwise, possessive quantifiers consume all characters that could have matched the following sub-patterns and nothing remains for the\nfollowing sub-patterns.\nNoncompliant code example\nPattern pattern1 = Pattern.compile(\"a++abc\");       // Noncompliant, the second 'a' never matches\nPattern pattern2 = Pattern.compile(\"\\\\d*+[02468]\"); // Noncompliant, the sub-pattern \"[02468]\" never matches\nCompliant solution\nPattern pattern1 = Pattern.compile(\"aa++bc\");            // Compliant, for example it can match \"aaaabc\"\nPattern pattern2 = Pattern.compile(\"\\\\d*+(?<=[02468])\"); // Compliant, for example it can match an even number like \"1234\""
    },
    {
        "id": 36,
        "title": "Annotated Mockito objects should be initialized",
        "description": "Objects annotated with Mockito annotations @Mock , @Spy , @Captor ,\u00a0or @InjectMocks need to be initialized explicitly.\nThere are several ways to do this:\nCall MockitoAnnotations.openMocks(this) or MockitoAnnotations.initMocks(this) in a setup method Annotate test class with @RunWith(MockitoJUnitRunner.class) (JUnit 4) Annotate test class with @ExtendWith(MockitoExtension.class) (JUnit 5 Jupiter) Use @Rule public MockitoRule rule = MockitoJUnit.rule();\nCall MockitoAnnotations.openMocks(this) or MockitoAnnotations.initMocks(this) in a setup method\nAnnotate test class with @RunWith(MockitoJUnitRunner.class) (JUnit 4)\nAnnotate test class with @ExtendWith(MockitoExtension.class) (JUnit 5 Jupiter)\nUse @Rule public MockitoRule rule = MockitoJUnit.rule();\nTest using uninitialized mocks will fail.\nNote that this only applies to annotated Mockito objects. It is not necessary to initialize objects instantiated via Mockito.mock() or Mockito.spy() .\nThis rule raises an issue when a test class uses uninitialized mocks.\nNoncompliant code example\npublic class FooTest { // Noncompliant: Mockito initialization missing\n  @Mock private Bar bar;\n\n  @Spy private Baz baz;\n\n  @InjectMocks private Foo fooUnderTest;\n\n  @Test\n  void someTest() {\n    // test something ...\n  }\n\n  @Nested\n  public class Nested {\n    @Mock\n    private Bar bar;\n  }\nCompliant solution\n@RunWith(MockitoJUnitRunner.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\n@ExtendWith(MockitoExtension.class)\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n}\npublic class FooTest {\n  @Rule\n  public MockitoRule rule = MockitoJUnit.rule();\n\n  @Mock private Bar bar;\n  // ...\n}\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n\n  @BeforeEach\n  void setUp() {\n    MockitoAnnotations.openMocks(this);\n  }\n  // ...\n}\npublic class FooTest {\n  @Mock private Bar bar;\n  // ...\n\n  @Before\n  void setUp() {\n    MockitoAnnotations.initMocks(this);\n  }\n  // ...\n}\n@ExtendWith(MockitoExtension.class)\npublic class FooTest {\n  @Nested\n  public class Nested {\n    @Mock\n    private Bar bar;\n  }\n}"
    },
    {
        "id": 37,
        "title": "Tests method should not be annotated with competing annotations",
        "description": "Annotating unit tests with more than one test-related annotation is not only useless but could also result in unexpected behavior like failing\ntests or unwanted side-effects.\nThis rule reports an issue when a test method is annotated with more than one of the following competing annotation:\n@Test @RepeatedTest @ParameterizedTest @TestFactory @TestTemplate\n@Test\n@RepeatedTest\n@ParameterizedTest\n@TestFactory\n@TestTemplate\nNoncompliant code example\n@Test\n@RepeatedTest(2) // Noncompliant, this test will be repeated 3 times\nvoid test() { }\n\n@ParameterizedTest\n@Test\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { } // Noncompliant, this test will fail with ParameterResolutionException\nCompliant solution\n@RepeatedTest(2)\nvoid test() { }\n\n@ParameterizedTest\n@MethodSource(\"methodSource\")\nvoid test2(int argument) { }"
    },
    {
        "id": 38,
        "title": "Assertions should not be used in production code",
        "description": "Assertions are intended to be used in test code, but not in production code. It is confusing, and might lead to ClassNotFoundException when the build tools only provide the required dependency in test scope.\nIn addition, assertions will throw a sub-class of Error : AssertionError , which should be avoided in production code.\nThis rule raises an issue when any assertion intended to be used in test is used in production code.\nSupported frameworks:\nJUnit FestAssert AssertJ\nJUnit\nFestAssert\nAssertJ\nNote: this does not apply for assert from Java itself or if the source code package name is related to tests (contains: test or assert or junit )."
    },
    {
        "id": 39,
        "title": "DateTimeFormatters should not use mismatched year and week numbers",
        "description": "When creating a DateTimeFormatter using the WeekFields.weekBasedYear() temporal field, the resulting year number may be\noff by 1 at the beginning of a new year (when the date to format is in a week that is shared by two consecutive years).\nUsing this year number in combination with an incompatible week temporal field yields a result that may be confused with the first week of the\nprevious year.\nInstead, when paired with a week temporal field, the week-based year should only be used with the week of week-based year temporal field WeekFields.weekOfWeekBasedYear() .\nAlternatively the temporal field ChronoField.ALIGNED_WEEK_OF_YEAR can be used together with a regular year (but not the week based\nyear).\nNoncompliant code example\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4) // Noncompliant: using week of week-based year with regular year\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4) // Noncompliant: using week of week-based year with regular year\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4) // Noncompliant: using aligned week of year with week-based year\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\nHere the first two formatters would wrongly format the 1st of January 2016 as \"2016-53\" while the last one would format it as \"2015-01\"\nCompliant solution\nnew DateTimeFormatterBuilder()\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4)\n      .appendLiteral('-')\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\n\nnew DateTimeFormatterBuilder()\n      .appendValue(ChronoField.YEAR_OF_ERA, 4)\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();\nHere the first formatter would format the 1st of January 2016 as \"2015-53\" while the last two would produce \"2016-01\", both of which are correct\ndepending on how you count the weeks.\nExceptions\nNo issue is raised when week-based year is not used in combination with a week temporal field.\nSimilarly, no issue is raised if week of week-based year is not used in combination with a year temporal field."
    },
    {
        "id": 40,
        "title": "Unicode Grapheme Clusters should be avoided inside regex character classes",
        "description": "When placing Unicode Grapheme Clusters (characters which require to be encoded in\nmultiple Code Points ) inside a character class of a regular expression, this will likely lead\nto unintended behavior.\nFor instance, the grapheme cluster c\u0308 requires two code points: one for 'c' , followed by one for the umlaut modifier '\\u{0308}' . If placed within a character class, such as [c\u0308] , the regex will consider the character class being the\nenumeration [c\\u{0308}] instead. It will, therefore, match every 'c' and every umlaut that isn\u2019t expressed as a\nsingle codepoint, which is extremely unlikely to be the intended behavior.\nThis rule raises an issue every time Unicode Grapheme Clusters are used within a character class of a regular expression.\nNoncompliant code example\n\"cc\u0308d\u0308d\".replaceAll(\"[c\u0308d\u0308]\", \"X\"); // Noncompliant, print \"XXXXXX\" instead of expected \"cXXd\".\nCompliant solution\n\"cc\u0308d\u0308d\".replaceAll(\"c\u0308|d\u0308\", \"X\"); // print \"cXXd\""
    },
    {
        "id": 41,
        "title": "Case insensitive Unicode regular expressions should enable the \"UNICODE_CASE\" flag",
        "description": "By default case insensitivity only affects letters in the ASCII range. This can be changed by either passing Pattern.UNICODE_CASE or Pattern.UNICODE_CHARACTER_CLASS as an argument to Pattern.compile or using (?u) or (?U) within the\nregex.\nIf not done, regular expressions involving non-ASCII letters will still handle those letters as being case sensitive.\nNoncompliant code example\nPattern.compile(\"s\u00f6me p\u00e4ttern\", Pattern.CASE_INSENSITIVE);\nstr.matches(\"(?i)s\u00f6me p\u00e4ttern\");\nstr.matches(\"(?i:s\u00f6me) p\u00e4ttern\");\nCompliant solution\nPattern.compile(\"s\u00f6me p\u00e4ttern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);\nstr.matches(\"(?iu)s\u00f6me p\u00e4ttern\");\nstr.matches(\"(?iu:s\u00f6me) p\u00e4ttern\");\n\n// UNICODE_CHARACTER_CLASS implies UNICODE_CASE\nPattern.compile(\"s\u00f6me p\u00e4ttern\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);\nstr.matches(\"(?iU)s\u00f6me p\u00e4ttern\");\nstr.matches(\"(?iU:s\u00f6me) p\u00e4ttern\");"
    },
    {
        "id": 42,
        "title": "Assertions should not compare an object to itself",
        "description": "Assertions comparing an object to itself are more likely to be bugs due to developer\u2019s carelessness.\nThis rule raises an issue when the actual expression matches the expected expression.\nNoncompliant code example\nassertThat(actual).isEqualTo(actual); // Noncompliant\nCompliant solution\nassertThat(actual).isEqualTo(expected);\nExceptions\nIn a unit test validating the equals(...) and hashCode() methods, it\u2019s legitimate to compare an object to itself. This\nrule does not raise an issue for isEqualTo , assertEquals or hasSameHashCodeAs when the unit test name contains\n(case insensitive): equal , hash_?code , object_?method . For example, in tests with the following names: test_equals , testEqual , test_hashCode , test_hash_code , test_object_methods .\nclass MyClassTest {\n  @Test\n  void test_equals_and_hash_code() {\n    MyClass obj = new MyClass();\n    assertThat(obj).isEqualTo(obj); // Compliant\n    assertThat(obj).hasSameHashCodeAs(obj); // Compliant\n  }\n}"
    },
    {
        "id": 43,
        "title": "Regular expressions should be syntactically valid",
        "description": "Regular expressions have their own syntax that is understood by regular expression engines. Those engines will throw an exception at runtime if\nthey are given a regular expression that does not conform to that syntax.\nTo avoid syntax errors, special characters should be escaped with backslashes when they are intended to be matched literally and references to\ncapturing groups should use the correctly spelled name or number of the group.\nTo match a literal string instead of a regular expression, either all special characters should be escaped, the Pattern.LITERAL flag\nor methods that don\u2019t use regular expressions should be used.\nNoncompliant code example\nPattern.compile(\"([\");\nstr.matches(\"([\");\nstr.replaceAll(\"([\", \"{\");\nstr.matches(\"(\\\\w+-(\\\\d+)\");\nCompliant solution\nPattern.compile(\"\\\\(\\\\[\");\nPattern.compile(\"([\", Pattern.LITERAL);\nstr.equals(\"([\");\nstr.replace(\"([\", \"{\");\nstr.matches(\"(\\\\w+)-(\\\\d+)\");"
    },
    {
        "id": 44,
        "title": "Regex alternatives should not be redundant",
        "description": "If an alternative in a regular expression only matches things that are already matched by another alternative, that alternative is redundant and\nserves no purpose.\nIn the best case this means that the offending subpattern is merely redundant and should be removed. In the worst case it\u2019s a sign that this regex\ndoes not match what it was intended to match and should be reworked.\nCode examples\n\"[ab]|a\"   // Noncompliant: the \"|a\" is redundant because \"[ab]\" already matches \"a\"\n\".*|a\"     // Noncompliant: .* matches everything, so any other alternative is redundant\n\"[ab]\"\n\".*\""
    },
    {
        "id": 45,
        "title": "Alternatives in regular expressions should be grouped when used with anchors",
        "description": "In regular expressions, anchors ( ^ , $ , \\A , \\Z and \\z ) have higher precedence than\nthe | operator. So in a regular expression like ^alt1|alt2|alt3$ , alt1 would be anchored to the beginning, alt3 to the end and alt2 wouldn\u2019t be anchored at all. Usually the intended behavior is that all alternatives are anchored at\nboth ends. To achieve this, a non-capturing group should be used around the alternatives.\nIn cases where it is intended that the anchors only apply to one alternative each, adding (non-capturing) groups around the anchors and the parts\nthat they apply to will make it explicit which parts are anchored and avoid readers misunderstanding the precedence or changing it because they\nmistakenly assume the precedence was not intended.\nNoncompliant code example\n^a|b|c$\nCompliant solution\n^(?:a|b|c)$\nor\n^a$|^b$|^c$\nor, if you do want the anchors to only apply to a and c respectively:\n(?:^a)|b|(?:c$)"
    },
    {
        "id": 46,
        "title": "Assertions comparing incompatible types should not be made",
        "description": "Assertions comparing incompatible types always fail, and negative assertions always pass. At best, negative assertions are useless. At worst, the\ndeveloper loses time trying to fix his code logic before noticing wrong assertions.\nDissimilar types are:\ncomparing a primitive with null comparing an object with an unrelated primitive (E.G. a string with an int) comparing unrelated classes comparing an array to a non-array comparing two arrays of dissimilar types\ncomparing a primitive with null\ncomparing an object with an unrelated primitive (E.G. a string with an int)\ncomparing unrelated classes\ncomparing an array to a non-array\ncomparing two arrays of dissimilar types\nThis rule also raises issues for unrelated class and interface or unrelated interface types in negative\nassertions. Because except in some corner cases, those types are more likely to be dissimilar. And inside a negative assertion, there is no test\nfailure to inform the developer about this unusual comparison.\nSupported test frameworks:\nJUnit4 JUnit5 AssertJ\nJUnit4\nJUnit5\nAssertJ\nNoncompliant code example\ninterface KitchenTool {}\ninterface Plant {}\nclass Spatula implements KitchenTool {}\nclass Tree implements Plant {}\n\nvoid assertValues(int size,\n                  Spatula spatula, KitchenTool tool,  KitchenTool[] tools,\n                  Tree    tree,    Plant       plant, Tree[]        trees) {\n\n  // Whatever the given values, those negative assertions will always pass due to dissimilar types:\n  assertThat(size).isNotNull();           // Noncompliant; primitives can not be null\n  assertThat(spatula).isNotEqualTo(tree); // Noncompliant; unrelated classes\n  assertThat(tool).isNotSameAs(tools);    // Noncompliant; array & non-array\n  assertThat(trees).isNotEqualTo(tools);  // Noncompliant; incompatible arrays\n\n  // Those assertions will always fail\n  assertThat(size).isNull();                       // Noncompliant\n  assertThat(spatula).isEqualTo(tree);             // Noncompliant\n\n  // Those negative assertions are more likely to always pass\n  assertThat(spatula).isNotEqualTo(plant); // Noncompliant; unrelated class and interface\n  assertThat(tool).isNotEqualTo(plant);    // Noncompliant; unrelated interfaces\n}"
    },
    {
        "id": 47,
        "title": "Repeated patterns in regular expressions should not match the empty string",
        "description": "A regex should never include a repetitive pattern whose body would match the empty string. This is usually a sign that a part of the regex is\nredundant or does not do what the author intended.\nNoncompliant code example\n\"(?:)*\"      // same as the empty regex, the '*' accomplishes nothing\n\"(?:|x)*\"    // same as the empty regex, the alternative has no effect\n\"(?:x|)*\"    // same as 'x*', the empty alternative has no effect\n\"(?:x*|y*)*\" // same as 'x*', the first alternative would always match, y* is never tried\n\"(?:x?)*\"    // same as 'x*'\n\"(?:x?)+\"    // same as 'x*'\nCompliant solution\n\"x*\""
    },
    {
        "id": 48,
        "title": "AssertJ assertions \"allMatch\" and \"doesNotContains\" should also test for emptiness",
        "description": "AssertJ assertions allMatch and doesNotContains on an empty list always\u00a0returns true whatever the content of the\npredicate. Despite being correct, you should make explicit if you expect an empty list or not, by adding isEmpty() / isNotEmpty() in addition to calling the assertion, or by testing the list\u2019s content further. It will justify the\nuseless predicate to improve clarity or increase the reliability of the test.\nThis rule raises an issue when any of the methods listed are used without asserting that the list is empty or not and without testing the\ncontent.\nTargetted methods:\nallMatch allSatisfy doesNotContain doesNotContainSequence doesNotContainSubsequence doesNotContainAnyElementsOf\nallMatch\nallSatisfy\ndoesNotContain\ndoesNotContainSequence\ndoesNotContainSubsequence\ndoesNotContainAnyElementsOf\nNoncompliant code example\nList<String> logs = getLogs();\n\nassertThat(logs).allMatch(e -> e.contains(\u201cerror\u201d)); // Noncompliant, this test pass if logs are empty!\nassertThat(logs).doesNotContain(\"error\"); // Noncompliant, do you expect any log?\nCompliant solution\nList<String> logs = getLogs();\n\nassertThat(logs).isNotEmpty().allMatch(e -> e.contains(\u201cerror\u201d));\n// Or\nassertThat(logs).hasSize(5).allMatch(e -> e.contains(\u201cerror\u201d));\n// Or\nassertThat(logs).isEmpty();\n\n// Despite being redundant, this is also acceptable since it explains why you expect an empty list\nassertThat(logs).doesNotContain(\"error\").isEmpty();\n// or test the content of the list further\nassertThat(logs).contains(\"warning\").doesNotContain(\"error\");"
    },
    {
        "id": 49,
        "title": "AssertJ methods setting the assertion context should come before an assertion",
        "description": "Describing, setting error message or adding a comparator in AssertJ must be done before calling the\nassertion, otherwise, settings will not be taken into account.\nThis rule raises an issue when one of the method (with all similar methods):\nas describedAs withFailMessage overridingErrorMessage usingComparator usingElementComparator extracting filteredOn\nas\ndescribedAs\nwithFailMessage\noverridingErrorMessage\nusingComparator\nusingElementComparator\nextracting\nfilteredOn\nis called without calling an AssertJ assertion afterward.\nNoncompliant code example\nassertThat(actual).isEqualTo(expected).as(\"Description\"); // Noncompliant\nassertThat(actual).isEqualTo(expected).withFailMessage(\"Fail message\"); // Noncompliant\nassertThat(actual).isEqualTo(expected).usingComparator(new CustomComparator()); // Noncompliant\nCompliant solution\nassertThat(actual).as(\"Description\").isEqualTo(expected);\nassertThat(actual).withFailMessage(\"Fail message\").isEqualTo(expected);\nassertThat(actual).usingComparator(new CustomComparator()).isEqualTo(expected);"
    },
    {
        "id": 50,
        "title": "AssertJ configuration should be applied",
        "description": "A org.assertj.core.configuration.Configuration will be effective only once you call Configuration.apply() or Configuration.applyAndDisplay() .\nThis rule raises an issue when configurations are set without the appropriate call to apply them.\nNoncompliant code example\nConfiguration configuration = new Configuration(); // Noncompliant, this configuration will not be applied.\nconfiguration.setComparingPrivateFields(true);\nCompliant solution\nConfiguration configuration = new Configuration();\nconfiguration.setComparingPrivateFields(true);\nconfiguration.applyAndDisplay();\n// Alternatively: configuration.apply();"
    },
    {
        "id": 51,
        "title": "JUnit5 test classes and methods should not be silently ignored",
        "description": "JUnit5 is more tolerant regarding the visibilities of Test classes and methods than JUnit4, which required everything to be public. JUnit5 supports\ndefault package, public and protected visibility, even if it is recommended to use the default package visibility, which improves the readability of\ncode.\nBut JUnit5 ignores without any warning:\nprivate classes and private methods static methods methods returning a value without being a TestFactory\nprivate classes and private methods\nstatic methods\nmethods returning a value without being a TestFactory\nNoncompliant code example\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  private void test1() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Test\n  static void test2() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Test\n  boolean test3() { // Noncompliant - ignored by JUnit5\n    // ...\n  }\n  @Nested\n  private class MyNestedClass { // Noncompliant - ignored by JUnit5\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}\nCompliant solution\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test1() {\n    // ...\n  }\n  @Test\n  void test2() {\n    // ...\n  }\n  @Test\n  void test3() {\n    // ...\n  }\n  @Nested\n  class MyNestedClass {\n    @Test\n    void test() {\n      // ...\n    }\n  }\n}"
    },
    {
        "id": 52,
        "title": "JUnit5 inner test classes should be annotated with @Nested",
        "description": "If not annotated with @Nested , an inner class containing some tests will never be executed during tests execution. While you could\nstill be able to manually run its tests in an IDE, it won\u2019t be the case during the build. By contrast, a static nested class containing some tests\nshould not be annotated with @Nested , JUnit5 will not share setup and state with an instance of its enclosing class.\nThis rule raises an issue on inner classes and static nested classes containing JUnit5 test methods which has a wrong usage of @Nested annotation.\nNote: This rule does not check if the context in which JUnit 5 is running (e.g. Maven Surefire Plugin) is properly configured to execute static\nnested classes, it could not be the case using the default configuration.\nNoncompliant code example\nimport org.junit.jupiter.api.Test;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  class InnerClassTest { // Noncompliant, missing @Nested annotation\n    @Test\n    void test() { /* ... */ }\n  }\n\n  @Nested\n  static class StaticNestedClassTest { // Noncompliant, invalid usage of @Nested annotation\n    @Test\n    void test() { /* ... */ }\n  }\n}\nCompliant solution\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Nested;\n\nclass MyJunit5Test {\n  @Test\n  void test() { /* ... */ }\n\n  @Nested\n  class InnerClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n\n  static class StaticNestedClassTest {\n    @Test\n    void test() { /* ... */ }\n  }\n}"
    },
    {
        "id": 53,
        "title": "Only one method invocation is expected when testing checked exceptions",
        "description": "When verifying that code raises an exception, a good practice is to avoid having multiple method calls inside the tested code, to be explicit about\nwhat is exactly tested.\nWhen two of the methods can raise the same checked exception, not respecting this good practice is a bug, since it is not possible\nto know what is really tested.\nYou should make sure that only one method can raise the expected checked exception in the tested code.\nNoncompliant code example\n@Test\npublic void testG() {\n  // Do you expect g() or f() throwing the exception?\n  assertThrows(IOException.class, () -> g(f(1)) ); // Noncompliant\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  try { // Noncompliant\n    g(f(1));\n    Assert.fail(\"Expected an IOException to be thrown\");\n  } catch (IOException e) {\n    // Test exception message...\n  }\n}\n\nint f(int x) throws IOException {\n  // ...\n}\n\nint g(int x) throws IOException {\n  // ...\n}\nCompliant solution\n@Test\npublic void testG() {\n  int y = f(1);\n  // It is explicit that we expect an exception from g() and not f()\n  assertThrows(IOException.class, () -> g(y) );\n}\n\n@Test\npublic void testGTryCatchIdiom() {\n  int y = f(1);\n  try {\n    g(y);\n    Assert.fail(\"Expected an IOException to be thrown\");\n  } catch (IOException e) {\n    // Test exception message...\n  }\n}"
    },
    {
        "id": 54,
        "title": "Assertion methods should not be used within the try block of a try-catch catching an Error",
        "description": "Assertion methods\u00a0are throwing a \" java.lang.AssertionError \". If this call is done within the try block of a try-catch cathing a\nsimilar error, you should make sure to test some properties of the exception. Otherwise, the assertion will never fail.\nNoncompliant code example\n@Test\npublic void should_throw_assertion_error() {\n  try {\n    throwAssertionError();\n    Assert.fail(\"Expected an AssertionError!\"); // Noncompliant, the AssertionError will be caught and the test will never fail.\n  } catch (AssertionError e) {}\n}\n\nprivate void throwAssertionError() {\n  throw new AssertionError(\"My assertion error\");\n}\nCompliant solution\nassertThrows(AssertionError.class, () -> throwAssertionError());\ntry {\n   throwAssertionError();\n   Assert.fail(\"Expected an AssertionError!\"); // Compliant, we made sure to test that the correct error is raised\n } catch (AssertionError e) {\n   Assert.assertThat(e.getMessage(), is(\"My assertion error\"));\n }"
    },
    {
        "id": 55,
        "title": "\"ThreadLocal\" variables should be cleaned up when no longer used",
        "description": "ThreadLocal variables are supposed to be garbage collected once the holding thread is no longer alive. Memory leaks can occur when\nholding threads are re-used which is the case on application servers using pool of threads.\nTo avoid such problems, it is recommended to always clean up ThreadLocal variables using the remove() method to remove\nthe current thread\u2019s value for the ThreadLocal variable.\nIn addition, calling set(null) to remove the value might keep the reference to this pointer in the map, which can cause\nmemory leak in some scenarios. Using remove is safer to avoid this issue.\nNoncompliant code example\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal<UserSession> DELEGATE = new ThreadLocal<>();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n   public void incorrectCleanup() {\n     DELEGATE.set(null); // Noncompliant\n   }\n\n  // some other methods without a call to DELEGATE.remove()\n}\nCompliant solution\npublic class ThreadLocalUserSession implements UserSession {\n\n  private static final ThreadLocal<UserSession> DELEGATE = new ThreadLocal<>();\n\n  public UserSession get() {\n    UserSession session = DELEGATE.get();\n    if (session != null) {\n      return session;\n    }\n    throw new UnauthorizedException(\"User is not authenticated\");\n  }\n\n  public void set(UserSession session) {\n    DELEGATE.set(session);\n  }\n\n  public void unload() {\n    DELEGATE.remove(); // Compliant\n  }\n\n  // ...\n}\nExceptions\nRule will not detect non-private ThreadLocal variables, because remove() can be called from another class."
    },
    {
        "id": 56,
        "title": "Strings and Boxed types should be compared using \"equals()\"",
        "description": "It\u2019s almost always a mistake to compare two instances of java.lang.String or boxed types like java.lang.Integer using\nreference equality == or != , because it is not comparing actual value but locations in memory.\nNoncompliant code example\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\nCompliant solution\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null && firstName.equals(lastName)) { ... };"
    },
    {
        "id": 57,
        "title": "\"@SpringBootApplication\" and \"@ComponentScan\" should not be used in the default package",
        "description": "@ComponentScan is used to determine which Spring Beans are available in the application context. The packages to scan can be\nconfigured thanks to the basePackageClasses or basePackages (or its alias value ) parameters. If neither\nparameter is configured, @ComponentScan will consider only the package of the class annotated with it. When @ComponentScan is used on a class belonging to the default package, the entire classpath will be scanned.\nThis will slow-down the start-up of the application and it is likely the application will fail to start with an BeanDefinitionStoreException because you ended up scanning the Spring Framework package itself.\nThis rule raises an issue when:\n@ComponentScan , @SpringBootApplication and @ServletComponentScan are used on a class belonging to the\n  default package @ComponentScan is explicitly configured with the default package\n@ComponentScan , @SpringBootApplication and @ServletComponentScan are used on a class belonging to the\n  default package\n@ComponentScan is explicitly configured with the default package\nNoncompliant code example\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // Noncompliant; RootBootApp is declared in the default package\npublic class RootBootApp {\n...\n}\n@ComponentScan(\"\")\npublic class Application {\n...\n}\nCompliant solution\npackage hello;\n\nimport org.springframework.boot.SpringApplication;\n\n@SpringBootApplication // Compliant; RootBootApp belongs to the \"hello\" package\npublic class RootBootApp {\n...\n}"
    },
    {
        "id": 58,
        "title": "InputSteam.read() implementation should not return a signed byte",
        "description": "According to the Java documentation, any implementation of the InputSteam.read() method is supposed to read the next byte of data from\nthe input stream. The value byte must be an int in the range 0 to 255. If no byte is available because the end of the stream has been\nreached, the value -1 is returned.\nBut in Java, the byte primitive data type is an 8-bit signed two\u2019s complement integer. It has a minimum value of -128 and a maximum\nvalue of 127. So by contract, the implementation of an InputSteam.read() method should never directly return a byte primitive data type. A conversion into an unsigned byte must be done before by applying a bitmask.\nNoncompliant code example\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++); // Noncompliant, a signed byte value is returned\n}\nCompliant solution\n@Override\npublic int read() throws IOException {\n  if (pos == buffer.length()) {\n    return -1;\n  }\n  return buffer.getByte(pos++) & 0xFF; // The 0xFF bitmask is applied\n}"
    },
    {
        "id": 59,
        "title": "\"compareTo\" should not be overloaded",
        "description": "When implementing the Comparable<T>.compareTo method, the parameter\u2019s type has to match the type used in the Comparable declaration. When a different type is used this creates an overload instead of an override, which is unlikely to be the\nintent.\nThis rule raises an issue when the parameter of the compareTo method of a class implementing Comparable<T> is not\nsame as the one used in the Comparable declaration.\nNoncompliant code example\npublic class Foo {\n  static class Bar implements Comparable<Bar> {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(FooBar rhs) {  // Noncompliant: Parameter should be of type Bar\n      return 0;\n    }\n  }\n}\nCompliant solution\npublic class Foo {\n  static class Bar implements Comparable<Bar> {\n    public int compareTo(Bar rhs) {\n      return -1;\n    }\n  }\n\n  static class FooBar extends Bar {\n    public int compareTo(Bar rhs) {\n      return 0;\n    }\n  }\n}"
    },
    {
        "id": 60,
        "title": "\"iterator\" should not return \"this\"",
        "description": "An Iterable should not implement the Iterator interface or return this as an Iterator . The\nreason is that Iterator represents the iteration process itself, while Iterable represents the object we want to iterate\nover.\nThe Iterator instance encapsulates state information of the iteration process, such as the current and next element. Consequently,\ndistinct iterations require distinct Iterator instances, for which Iterable provides the factory method Iterable.iterator() .\nThis rule raises an issue when the Iterable.iterator() of a class implementing both Iterable and Iterator returns this .\nWhat is the potential impact?\nThe Iterable.iterator() method returning the same Iterator instance many times would have the following effects:\nFor subsequent iterations, e.g., two subsequent for loops with iterators over the same object, only the first one would iterate,\n  and the others would do nothing.\nFor nested iterations over the same object, the different iteration processes would affect each other because they only have a common, shared\n  state."
    },
    {
        "id": 61,
        "title": "Getters and setters should access the expected fields",
        "description": "Getters and setters provide a way to enforce encapsulation by providing public methods that give controlled access to private fields. However, in classes with multiple fields, it is not unusual that copy and paste is used to quickly create the needed\ngetters and setters, which can result in the wrong field being accessed by a getter or setter.\nThis rule raises an issue in any of these cases:\nA setter does not update the field with the corresponding name. A getter does not access the field with the corresponding name.\nA setter does not update the field with the corresponding name.\nA getter does not access the field with the corresponding name.\nNoncompliant code example\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) { // Noncompliant: field 'x' is not updated\n    this.y = val;\n  }\n\n  public int getY() { // Noncompliant: field 'y' is not used in the return value\n    return this.x;\n  }\n}\nCompliant solution\nclass A {\n  private int x;\n  private int y;\n\n  public void setX(int val) {\n    this.x = val;\n  }\n\n  public int getY() {\n    return this.y;\n  }\n}"
    },
    {
        "id": 62,
        "title": "Map values should not be replaced unconditionally",
        "description": "Storing a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".\nletters.put(\"a\", \"Apple\");\nletters.put(\"a\", \"Boy\");  // Noncompliant\n\ntowns[i] = \"London\";\ntowns[i] = \"Chicago\";  // Noncompliant\nThis practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo."
    },
    {
        "id": 63,
        "title": "Week Year (\"YYYY\") should not be used for date formatting",
        "description": "Few developers are aware of the difference between Y for \"Week year\" and y for Year when formatting and parsing a date\nwith SimpleDateFormat or DateTimeFormatter . That\u2019s likely because for most dates, Week year and Year are the same, so\ntesting at any time other than the first or last week of the year will yield the same value for both y and Y . But in the\nlast week of December and the first week of January, you may get unexpected results.\nAccording to the Javadoc :\nA week year is in sync with a WEEK_OF_YEAR cycle. All weeks between the first and last weeks (inclusive) have the same week year value.\n  Therefore, the first and last days of a week year may have different calendar year values.\nFor example, January 1, 1998 is a Thursday. If getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4 (ISO 8601 standard compatible\n  setting), then week 1 of 1998 starts on December 29, 1997, and ends on January 4, 1998. The week year is 1998 for the last three days of calendar\n  year 1997. If, however, getFirstDayOfWeek() is SUNDAY, then week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three\n  days of 1998 then are part of week 53 of 1997 and their week year is 1997.\nNoncompliant code example\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY/MM/dd\").format(date);   //Noncompliant; yields '2016/12/31'\nresult = DateTimeFormatter.ofPattern(\"YYYY/MM/dd\").format(date); //Noncompliant; yields '2016/12/31'\nCompliant solution\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"yyyy/MM/dd\").format(date);   //Yields '2015/12/31' as expected\nresult = DateTimeFormatter.ofPattern(\"yyyy/MM/dd\").format(date); //Yields '2015/12/31' as expected\nExceptions\nDate date = new SimpleDateFormat(\"yyyy/MM/dd\").parse(\"2015/12/31\");\nString result = new SimpleDateFormat(\"YYYY-ww\").format(date);  //compliant, 'Week year' is used along with 'Week of year'. result = '2016-01'\nDateTimeFormatter.ofPattern(\"YYYY-ww\").format(date); //compliant; yields '2016-01' as expected"
    },
    {
        "id": 64,
        "title": "Exceptions should not be created without being thrown",
        "description": "Creating a new Throwable without actually throwing it is useless and is probably due to a mistake.\nNoncompliant code example\nif (x < 0)\n  new IllegalArgumentException(\"x must be nonnegative\");\nCompliant solution\nif (x < 0)\n  throw new IllegalArgumentException(\"x must be nonnegative\");"
    },
    {
        "id": 65,
        "title": "Collection sizes and array length comparisons should make sense",
        "description": "The size of a collection and the length of an array are always greater than or equal to zero. Testing it doesn\u2019t make sense, since the result is\nalways true .\nif (myList.size() >= 0) {...} // Noncompliant: always true\n\nboolean result = myArray.length >= 0; // Noncompliant: true\nSimilarly testing that it is less than zero will always return false .\nif (myList.size() < 0) {...} // Noncompliant: always false\nFix the code to properly check for emptiness if it was the intent, or remove the redundant code to keep the current behavior."
    },
    {
        "id": 66,
        "title": "Consumed Stream pipelines should not be reused",
        "description": "Stream operations are divided into intermediate and terminal operations, and are combined to form stream pipelines. After the terminal operation is\nperformed, the stream pipeline is considered consumed, and cannot be used again. Such a reuse will yield unexpected results.\nNoncompliant code example\nStream<Widget> pipeline = widgets.stream().filter(b -> b.getColor() == RED);\nint sum1 = pipeline.sum();\nint sum2 = pipeline.mapToInt(b -> b.getWeight()).sum(); // Noncompliant"
    },
    {
        "id": 67,
        "title": "Intermediate Stream methods should not be left unused",
        "description": "There are two types of stream operations: intermediate operations, which return another stream, and terminal operations, which return something\nother than a stream. Intermediate operations are lazy, meaning they aren\u2019t actually executed until and unless a terminal stream operation is performed\non their results. Consequently, if the result of an intermediate stream operation is not fed to a terminal operation, it serves no purpose, which is\nalmost certainly an error.\nNoncompliant code example\nwidgets.stream().filter(b -> b.getColor() == RED); // Noncompliant\nCompliant solution\nint sum = widgets.stream()\n                      .filter(b -> b.getColor() == RED)\n                      .mapToInt(b -> b.getWeight())\n                      .sum();\nStream<Widget> pipeline = widgets.stream()\n                                 .filter(b -> b.getColor() == GREEN)\n                                 .mapToInt(b -> b.getWeight());\nsum = pipeline.sum();"
    },
    {
        "id": 68,
        "title": "All branches in a conditional structure should not have exactly the same implementation",
        "description": "Having all branches of a switch or if chain with the same implementation indicates a problem.\nIn the following code:\nif (b == 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b = a > 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\nEither there is a copy-paste error that needs fixing or an unnecessary switch or if chain that should be removed.\nExceptions\nThis rule does not apply to if chains without else , nor to switch without a default clause.\nif(b == 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b == 1) {\n  doSomething();\n}"
    },
    {
        "id": 69,
        "title": "\"@Controller\" classes that use \"@SessionAttributes\" must call \"setComplete\" on their \"SessionStatus\" objects",
        "description": "A Spring @Controller that uses @SessionAttributes is designed to handle a stateful / multi-post form. Such @Controller s use the specified @SessionAttributes to store data on the server between requests. That data should be cleaned\nup when the session is over, but unless setComplete() is called on the SessionStatus object from a @RequestMapping method, neither Spring nor the JVM will know it\u2019s time to do that. Note that the SessionStatus object must\nbe passed to that method as a parameter.\nNoncompliant code example\n@Controller\n@SessionAttributes(\"hello\")  // Noncompliant; this doesn't get cleaned up\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n}\nCompliant solution\n@Controller\n@SessionAttributes(\"hello\")\npublic class HelloWorld {\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    return \"Hello \" + greetee;\n  }\n\n  @RequestMapping(\"/goodbye\", method = POST)\n  public String goodbye(SessionStatus status) {\n    //...\n    status.setComplete();\n  }\n\n}"
    },
    {
        "id": 70,
        "title": "Spring \"@Controller\" classes should not use \"@Scope\"",
        "description": "Spring @Controller s, @Service s, and @Repository s have singleton scope by default, meaning only\none instance of the class is ever instantiated in the application. Defining any other scope for one of these class types will result in needless churn\nas new instances are created and destroyed. In a busy web application, this could cause a significant amount of needless additional load on the\nserver.\nThis rule raises an issue when the @Scope annotation is applied to a @Controller , @Service , or @Repository with any value but \"singleton\". @Scope(\"singleton\") is redundant, but ignored.\nNoncompliant code example\n@Scope(\"prototype\")  // Noncompliant\n@Controller\npublic class HelloWorld {\nCompliant solution\n@Controller\npublic class HelloWorld {"
    },
    {
        "id": 71,
        "title": "Optional value should only be accessed after calling isPresent()",
        "description": "Optional value can hold either a value or not. The value held in the Optional can be accessed using the get() method, but it will throw a\nNoSuchElementException if there is no value present. To avoid the exception, calling the isPresent() or !\nisEmpty() method should always be done before any call to get() .\nAlternatively, note that other methods such as orElse(...) , orElseGet(...) or orElseThrow(...) can be used\nto specify what to do with an empty Optional .\nNoncompliant code example\nOptional<String> value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.get(); // Noncompliant\nif (methodThatReturnsOptional().isEmpty()) {\n  throw new NotFoundException();\n}\nString value = methodThatReturnsOptional().get(); // Noncompliant: indirect access, we consider that two consecutive calls can return different values.\nCompliant solution\nthis.getOptionalValue().ifPresent(stringValue ->\n  // Do something with stringValue\n);\nor\nOptional<String> value = this.getOptionalValue();\n\n// ...\n\nif (value.isPresent()) {\n  String stringValue = value.get();\n}\nor\nOptional<String> value = this.getOptionalValue();\n\n// ...\n\nString stringValue = value.orElse(\"default\");\nOptional<String> optional = methodThatReturnsOptional();\nif (optional.isEmpty()) {\n  throw new NotFoundException();\n}\nString value = optional.get();"
    },
    {
        "id": 72,
        "title": "Double Brace Initialization should not be used",
        "description": "Because Double Brace Initialization (DBI) creates an anonymous class with a reference to the instance of the owning object, its use can lead to\nmemory leaks if the anonymous inner class is returned and held by other objects. Even when there\u2019s no leak, DBI is so obscure that it\u2019s bound to\nconfuse most maintainers.\nFor collections, use Arrays.asList instead, or explicitly add each item directly to the collection.\nNoncompliant code example\nMap source = new HashMap(){{ // Noncompliant\n    put(\"firstName\", \"John\");\n    put(\"lastName\", \"Smith\");\n}};\nCompliant solution\nMap source = new HashMap();\n// ...\nsource.put(\"firstName\", \"John\");\nsource.put(\"lastName\", \"Smith\");\n// ..."
    },
    {
        "id": 73,
        "title": "Overrides should match their parent class methods in synchronization",
        "description": "When @Overrides of synchronized methods are not themselves synchronized , the result can be improper\nsynchronization as callers rely on the thread-safety promised by the parent class.\nNoncompliant code example\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n @Override\n  public void foo () {  // Noncompliant\n    // ...\n    super.foo();\n  }\n}\nCompliant solution\npublic class Parent {\n\n  synchronized void foo() {\n    //...\n  }\n}\n\npublic class Child extends Parent {\n\n  @Override\n  synchronized void foo () {\n    // ...\n    super.foo();\n  }\n}"
    },
    {
        "id": 74,
        "title": "Custom resources should be closed",
        "description": "Leaking resources in an application is never a good idea, as it can lead to memory issues, and even the crash of the application. This rule\ntemplate allows you to specify which constructions open a resource and how it is closed in order to raise issue within a method scope when custom\nresources are leaked."
    },
    {
        "id": 75,
        "title": "Zero should not be a possible denominator",
        "description": "A division ( / ) or remainder operation ( % ) by zero indicates a bug or logical error. This is because in Java, a division\nor remainder operation where the denominator is zero and not a floating point value always results in an ArithmeticException being\nthrown.\nWhen working with double or float values, no exception will be thrown, but the operation will result in special floating\npoint values representing either positive infinity, negative infinity, or NaN . Unless these special values are explicitly handled by a\nprogram, zero denominators should be avoided in floating point operations, too. Otherwise, the application might produce unexpected results.\nWhat is the potential impact?\nIssues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss.\nIf the computation of the denominator is tied to user input data, this issue can potentially even be exploited by attackers to disrupt your\napplication.\nNoncompliant code example\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n  }\n  z = 1 / z; // Noncompliant, possible division by zero\n}\nCompliant solution\nvoid test_divide() {\n  int z = 0;\n  if (unknown()) {\n    // ..\n    z = 3;\n  } else {\n    // ..\n    z = 1;\n  }\n  z = 1 / z;\n}"
    },
    {
        "id": 76,
        "title": "Value-based classes should not be used for locking",
        "description": "According to the documentation,\nA program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly\n  via reference equality or indirectly via an appeal to synchronization\u2026\u200b\nThis is because value-based classes are intended to be wrappers for value types, which will be primitive-like collections of data (similar to struct s in other languages) that will come in future versions of Java.\nInstances of a value-based class \u2026\u200b\ndo not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of\n    returned instances;\ndo not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of\n    returned instances;\nThis means that you can\u2019t be sure you\u2019re the only one trying to lock on any given instance of a value-based class, opening your code up to\ncontention and deadlock issues.\nUnder Java 8 breaking this rule may not actually break your code, but there are no guarantees of the behavior beyond that.\nThis rule raises an issue when a known value-based class is used for synchronization. That includes all the classes in the java.time package except Clock ; the date classes for alternate calendars, HijrahDate , JapaneseDate , MinguoDate , ThaiBuddhistDate ; and the optional classes: Optional , OptionalDouble , OptionalLong , OptionalInt .\nNote that this rule is automatically disabled when the project\u2019s sonar.java.source is lower than 8 .\nNoncompliant code example\nOptional<Foo> fOpt = doSomething();\nsynchronized (fOpt) {  // Noncompliant\n  // ...\n}"
    },
    {
        "id": 77,
        "title": "Expressions used in \"assert\" should not produce side effects",
        "description": "Since assert statements aren\u2019t executed by default (they must be enabled with JVM flags) developers should never rely on their\nexecution the evaluation of any logic required for correct program function.\nNoncompliant code example\nassert myList.remove(myList.get(0));  // Noncompliant\nCompliant solution\nboolean removed = myList.remove(myList.get(0));\nassert removed;"
    },
    {
        "id": 78,
        "title": "Constructor injection should be used instead of field injection",
        "description": "Field injection seems like a tidy way to get your classes what they need to do their jobs, but it\u2019s really a NullPointerException waiting to happen unless all your class constructors are private . That\u2019s because any class instances that are constructed by callers,\nrather than instantiated by a Dependency Injection framework compliant with the JSR-330 (Spring, Guice, \u2026\u200b), won\u2019t have the ability to perform the\nfield injection.\nInstead @Inject should be moved to the constructor and the fields required as constructor parameters.\nThis rule raises an issue when classes with non- private constructors (including the default constructor) use field injection.\nNoncompliant code example\nclass MyComponent {  // Anyone can call the default constructor\n\n  @Inject MyCollaborator collaborator;  // Noncompliant\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();  // this will fail in classes new-ed by a caller\n  }\n}\nCompliant solution\nclass MyComponent {\n\n  private final MyCollaborator collaborator;\n\n  @Inject\n  public MyComponent(MyCollaborator collaborator) {\n    Assert.notNull(collaborator, \"MyCollaborator must not be null!\");\n    this.collaborator = collaborator;\n  }\n\n  public void myBusinessMethod() {\n    collaborator.doSomething();\n  }\n}"
    },
    {
        "id": 79,
        "title": "\"volatile\" variables should not be used with compound operators",
        "description": "Using compound operators as well as increments and decrements (and toggling, in the case of boolean s) on primitive fields are not\natomic operations. That is, they don\u2019t happen in a single step. For instance, when a volatile primitive field is incremented or\ndecremented you run the risk of data loss if threads interleave in the steps of the update. Instead, use a guaranteed-atomic class such as AtomicInteger , or synchronize the access.\nNoncompliant code example\nprivate volatile int count = 0;\nprivate volatile boolean boo = false;\n\npublic void incrementCount() {\n  count++;  // Noncompliant\n}\n\npublic void toggleBoo(){\n  boo = !boo;  // Noncompliant\n}\nCompliant solution\nprivate AtomicInteger count = 0;\nprivate boolean boo = false;\n\npublic void incrementCount() {\n  count.incrementAndGet();\n}\n\npublic synchronized void toggleBoo() {\n  boo = !boo;\n}"
    },
    {
        "id": 80,
        "title": "Non-primitive fields should not be \"volatile\"",
        "description": "Marking an array volatile means that the array itself will always be read fresh and never thread cached, but the items in the\narray will not be. Similarly, marking a mutable object field volatile means the object reference is volatile but\nthe object itself is not, and other threads may not see updates to the object state.\nThis can be salvaged with arrays by using the relevant AtomicArray class, such as AtomicIntegerArray , instead. For mutable objects,\nthe volatile should be removed, and some other method should be used to ensure thread-safety, such as synchronization, or ThreadLocal\nstorage.\nNoncompliant code example\nprivate volatile int [] vInts;  // Noncompliant\nprivate volatile MyObj myObj;  // Noncompliant\nCompliant solution\nprivate AtomicIntegerArray vInts;\nprivate MyObj myObj;"
    },
    {
        "id": 81,
        "title": "\"getClass\" should not be used for synchronization",
        "description": "getClass should not be used for synchronization in non- final classes because child classes will synchronize on a\ndifferent object than the parent or each other, allowing multiple threads into the code block at once, despite the synchronized keyword.\nInstead, hard code the name of the class on which to synchronize or make the class final .\nNoncompliant code example\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (this.getClass()) {  // Noncompliant\n      // ...\n    }\n  }\nCompliant solution\npublic class MyClass {\n  public void doSomethingSynchronized(){\n    synchronized (MyClass.class) {\n      // ...\n    }\n  }"
    },
    {
        "id": 82,
        "title": "Min and max used in combination should not always return the same value",
        "description": "When using Math.min() and Math.max() together for bounds checking, it\u2019s important to feed the right operands to each\nmethod. Math.min() should be used with the upper end of the range being checked, and Math.max() should be\nused with the lower end of the range. Get it backwards, and the result will always be the same end of the range.\nNoncompliant code example\nprivate static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.min(LOWER, num);  // result = 0\n    return Math.max(UPPER, result);     // Noncompliant; result is now 20: even though 12 was in the range\n  }\nCompliant solution\nSwapping method min() and max() invocations without changing parameters.\nprivate static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.max(LOWER, num);  // result = 12\n    return Math.min(UPPER, result);     // Compliant; result is still 12\n  }\nor swapping bounds UPPER and LOWER used as parameters without changing the invoked methods.\nprivate static final int UPPER = 20;\n  private static final int LOWER = 0;\n\n  public int doRangeCheck(int num) {    // Let's say num = 12\n    int result = Math.min(UPPER, num);  // result = 12\n    return Math.max(LOWER, result);     // Compliant; result is still 12\n  }"
    },
    {
        "id": 83,
        "title": "Assignment of lazy-initialized members should be the last step with double-checked locking",
        "description": "Double-checked locking can be used for lazy initialization of volatile fields, but only if field assignment is the last step in the synchronized block. Otherwise you run the risk of threads accessing a half-initialized object.\nNoncompliant code example\npublic class MyClass {\n\n  private volatile List<String> strings;\n\n  public List<String> getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          strings = new ArrayList<>();  // Noncompliant\n          strings.add(\"Hello\");  //When threadA gets here, threadB can skip the synchronized block because check#1 is false\n          strings.add(\"World\");\n        }\n      }\n    }\n    return strings;\n  }\n}\nCompliant solution\npublic class MyClass {\n\n  private volatile List<String> strings;\n\n  public List<String> getStrings() {\n    if (strings == null) {  // check#1\n      synchronized(MyClass.class) {\n        if (strings == null) {\n          List<String> tmpList = new ArrayList<>();\n          tmpList.add(\"Hello\");\n          tmpList.add(\"World\");\n          strings = tmpList;\n        }\n      }\n    }\n    return strings;\n  }\n}"
    },
    {
        "id": 84,
        "title": "\"wait\" should not be called when multiple locks are held",
        "description": "When two locks are held simultaneously, a wait call only releases one of them. The other will be held until some other thread requests\na lock on the awaited object. If no unrelated code tries to lock on that object, then all other threads will be locked out, resulting in a\ndeadlock.\nNoncompliant code example\nsynchronized (this.mon1) {  // threadB can't enter this block to request this.mon2 lock & release threadA\n\tsynchronized (this.mon2) {\n\t\tthis.mon2.wait();  // Noncompliant; threadA is stuck here holding lock on this.mon1\n\t}\n}"
    },
    {
        "id": 85,
        "title": "Indexes to passed to \"String\" operations should be within the string's bounds",
        "description": "There are various String operations that take one or more character indexes as arguments and return a portion of the original string.\nIndexing in this context is zero-based, meaning that the first character\u2019s index is 0 . As a result, given a string myString ,\nits last character is at index myString.length() - 1 .\nThe String operation methods throw a StringIndexOutOfBoundsException when one of their index argument is smaller than 0\n(E.G.: -1). String::substring also throws this exception when the beginIndex or endIndex argument is larger\nthan myString.length() , and String::charAt when the index argument is larger than myString.length() -\n1 For instance, it is not possible to use String::charAt to retrieve a value before the start or after the end of a string.\nFurthermore, it is not possible to use String::substring with beginIndex > endIndex to reverse the order of characters in\na string.\nThis rule raises an issue when a negative literal or an index that is too large is passed as an argument to the String::substring , String::charAt , and related methods. It also raises an issue when the start index passed to String::substring is larger than\nthe end index."
    },
    {
        "id": 86,
        "title": "Raw byte values should not be used in bitwise operations in combination with shifts",
        "description": "In Java, numeric promotions happen when two operands of an arithmetic expression have different sizes. More specifically, narrower operands get\npromoted to the type of wider operands. For instance, an operation between a byte and an int , will trigger a promotion of\nthe byte operand, converting it into an int .\nWhen this happens, the sequence of 8 bits that represents the byte will need to be extended to match the 32-bit long sequence that\nrepresents the int operand. Since Java uses two\u2019s complement notation for signed number types, the promotion will fill the missing\nleading bits with zeros or ones, depending on the sign of the value. For instance, the byte 0b1000_0000 (equal to -128 in\ndecimal notation), when promoted to int , will become 0b1111_1111_1111_1111_1111_1111_1000_0000 .\nWhen performing shifting or bitwise operations without considering that bytes are signed, the bits added during the promotion may have unexpected\neffects on the final result of the operations."
    },
    {
        "id": 87,
        "title": "JEE applications should not \"getClassLoader\"",
        "description": "Using the standard getClassLoader() may not return the right class loader in a JEE context. Instead, go through the currentThread .\nNoncompliant code example\nClassLoader cl = this.getClass().getClassLoader();  // Noncompliant\nCompliant solution\nClassLoader cl = Thread.currentThread().getContextClassLoader();"
    },
    {
        "id": 88,
        "title": "\"Collection.toArray()\" should be passed an array of the proper type",
        "description": "The Collection.toArray() method returns an Object[] when no arguments are provided to it. This can lead to a ClassCastException at runtime if you try to cast the returned array to an array of a specific type. Instead, use this method by providing\nan array of the desired type as the argument.\nNote that passing a new T[0] array of length zero as the argument is more efficient than a pre-sized array new\nT[size] .\nCode examples\npublic String [] getStringArray(List<String> strings) {\n  return (String []) strings.toArray();  // Noncompliant, a ClassCastException will be thrown here\n}\npublic String [] getStringArray(List<String> strings) {\n  return strings.toArray(new String[0]); // Compliant, the toArray method will return an array of the desired type, and we can remove the casting operation\n}\npublic String [] getPresizedStringArray(List<String> strings) {\n  return strings.toArray(new String[strings.size()]); // Compliant, but slightly less efficient than the previous example\n}"
    },
    {
        "id": 89,
        "title": "Getters and setters should be synchronized in pairs",
        "description": "A synchronized method is a method marked with the synchronized keyword, meaning it can only be accessed by one thread at a time. If\nmultiple threads try to access the synchronized method simultaneously, they will be blocked until the method is available.\nSynchronized methods prevent race conditions and data inconsistencies in multi-threaded environments. Ensuring that only one thread can access a\nmethod at a time, prevents multiple threads from modifying the same data simultaneously, and causing conflicts.\nWhen one part of a getter/setter pair is synchronized the other should be too. Failure to synchronize both sides may result in\ninconsistent behavior at runtime as callers access an inconsistent method state.\nThis rule raises an issue when either the method or the contents of one method in a getter/setter pair are synchronized, but the other is not."
    },
    {
        "id": 90,
        "title": "Non-thread-safe fields should not be static",
        "description": "When an object is marked as static , it means that it belongs to the class rather than any class instance. This means there is only one\ncopy of the static object in memory, regardless of how many class instances are created. Static objects are shared among all instances of the class\nand can be accessed using the class name rather than an instance of the class.\nA data type is considered thread-safe if it can be used correctly by multiple threads, regardless of how those threads are executed, without\nrequiring additional coordination from the calling code. In other words, a thread-safe data type can be accessed and modified by multiple threads\nsimultaneously without causing any issues or requiring extra work from the programmer to ensure correct behavior.\nNon-thread-safe objects are objects that are not designed to be used in a multi-threaded environment and can lead to race conditions and data\ninconsistencies when accessed by multiple threads simultaneously. Using them in a multi-threaded manner is highly likely to cause data problems or\nexceptions at runtime.\nWhen a non-thread-safe object is marked as static in a multi-threaded environment, it can cause issues because the non-thread-safe object will be\nshared across different instances of the containing class.\nThis rule raises an issue when any of the following instances and their subtypes are marked as static :\njava.util.Calendar , java.text.DateFormat , javax.xml.xpath.XPath , or javax.xml.validation.SchemaFactory .\njava.util.Calendar ,\njava.text.DateFormat ,\njavax.xml.xpath.XPath , or\njavax.xml.validation.SchemaFactory ."
    },
    {
        "id": 91,
        "title": "\"null\" should not be used with \"Optional\"",
        "description": "Optional acts as a container object that may or may not contain a non-null value. It is introduced in Java 8 to help avoid NullPointerException . It provides methods to check if a value is present and retrieve the value if it is present.\nOptional is used instead of null values to make the code more readable and avoid potential errors.\nIt is a bad practice to use null with Optional because it is unclear whether a value is present or not, leading to\nconfusion and potential NullPointerException errors."
    },
    {
        "id": 92,
        "title": "Unary prefix operators should not be repeated",
        "description": "The repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:\nint i = 1;\n\nint j = - - -i;  // Noncompliant: equivalent to \"-i\"\nint k = ~~~i;    // Noncompliant: equivalent to \"~i\"\nint m = + +i;    // Noncompliant: equivalent to \"i\"\n\nboolean b = false;\nboolean c = !!!b;   // Noncompliant\nOn the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:\nint i = 1;\nint j = ++ ++i;  // Noncompliant\nint k = i-- --; // Noncompliant\nUsing += or -= improves readability:\nint i = 1;\ni += 2;\nint j = i;\nint k = i;\ni -=2;\nThis rule raises an issue for repetitions of ! , ~ , - , + , prefix increments ++ and\nprefix decrements -- .\nExceptions\nOverflow handling for GWT compilation using ~~ is ignored."
    },
    {
        "id": 93,
        "title": "Non-existent operators like \"=+\" should not be used",
        "description": "Using operator pairs ( =+ , =- , or =! ) that look like reversed single operators ( += , -= or != ) is confusing. They compile and run but do not produce the same result as their mirrored counterpart.\nint target = -5;\nint num = 3;\n\ntarget =- num;  // Noncompliant: target = -3. Is that the intended behavior?\ntarget =+ num; // Noncompliant: target = 3\nThis rule raises an issue when =+ , =- , or =! are used without any space between the operators and when there\nis at least one whitespace after.\nReplace the operators with a single one if that is the intention\nint target = -5;\nint num = 3;\n\ntarget -= num;  // target = -8\nOr fix the spacing to avoid confusion\nint target = -5;\nint num = 3;\n\ntarget = -num;  // target = -3"
    },
    {
        "id": 94,
        "title": "\"PreparedStatement\" and \"ResultSet\" methods should be called with valid indices",
        "description": "PreparedStatement is an object that represents a precompiled SQL statement, that can be used to execute the statement multiple times\nefficiently.\nResultSet is the Java representation of the result set of a database query obtained from a Statement object. A default ResultSet object is not updatable and has a cursor that moves forward only.\nThe parameters in PreparedStatement and ResultSet are indexed beginning at 1, not 0. When an invalid index is passed to\nthe PreparedStatement or ResultSet methods, an IndexOutOfBoundsException is thrown. This can cause the program\nto crash or behave unexpectedly, leading to a poor user experience.\nThis rule raises an issue for the get methods in PreparedStatement and the set methods in ResultSet ."
    },
    {
        "id": 95,
        "title": "Files opened in append mode should not be used with \"ObjectOutputStream\"",
        "description": "An ObjectOutputStream writes primitive data types and graphs of Java objects to an OutputStream . The objects can be read\n(reconstituted) using an ObjectInputStream .\nWhen ObjectOutputStream is used with files opened in append mode, it can cause data corruption and unexpected behavior. This is\nbecause when ObjectOutputStream is created, it writes metadata to the output stream, which can conflict with the existing metadata when\nthe file is opened in append mode. This can lead to errors and data loss.\nWhen used with serialization, an ObjectOutputStream first writes the serialization stream header. This header should appear once per\nfile at the beginning. When you\u2019re trying to read your object(s) back from the file, only the first one will be read successfully, and a StreamCorruptedException will be thrown after that."
    },
    {
        "id": 96,
        "title": "\"read\" and \"readLine\" return values should be used",
        "description": "The Reader.read() and the BufferedReader.readLine() are used for reading data from a data source. The return value of\nthese methods is the data read from the data source, or null when the end of the data source is reached. If the return value is ignored,\nthe data read from the source is thrown away and may indicate a bug.\nThis rule raises an issue when the return values of Reader.read() and BufferedReader.readLine() and their subclasses are\nignored or merely null-checked.\nNoncompliant code example\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    while (buffReader.readLine() != null) { // Noncompliant\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}\nCompliant solution\npublic void doSomethingWithFile(String fileName) {\n  try(BufferedReader buffReader = new BufferedReader(new FileReader(fileName))) {\n    String line = null;\n    while ((line = buffReader.readLine()) != null) {\n      // ...\n    }\n  } catch (IOException e) {\n    // ...\n  }\n}"
    },
    {
        "id": 97,
        "title": "\"Math.abs\" and negation should not be used on numbers that could be \"MIN_VALUE\"",
        "description": "This rule involves the use of Math.abs and negation on numbers that could be MIN_VALUE . It is a problem because it can\nlead to incorrect results and unexpected behavior in the program.\nWhen Math.abs and negation are used on numbers that could be MIN_VALUE , the result can be incorrect due to integer\noverflow. Common methods that can return a MIN_VALUE and raise an issue when used together with Math.abs are:\nRandom.nextInt() and Random.nextLong() hashCode() compareTo()\nRandom.nextInt() and Random.nextLong()\nhashCode()\ncompareTo()\nAlternatively, the absExact() method throws an ArithmeticException for MIN_VALUE .\nNoncompliant code example\npublic void doSomething(String str) {\n  if (Math.abs(str.hashCode()) > 0) { // Noncompliant\n    // ...\n  }\n}\nCompliant solution\npublic void doSomething(String str) {\n  if (str.hashCode() != 0) {\n    // ...\n  }\n}"
    },
    {
        "id": 98,
        "title": "The value returned from a stream read should be checked",
        "description": "You cannot assume that any given stream reading call will fill the byte[] passed in to the method. Instead, you must check the value\nreturned by the read method to see how many bytes were read. Fail to do so, and you introduce bug that is both harmful and difficult to reproduce.\nSimilarly, you cannot assume that InputStream.skip will actually skip the requested number of bytes, but must check the value returned\nfrom the method.\nThis rule raises an issue when an InputStream.read method that accepts a byte[] is called, but the return value is not\nchecked, and when the return value of InputStream.skip is not checked. The rule also applies to InputStream child\nclasses.\nNoncompliant code example\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    is.read(buffer);  // Noncompliant\n    // ...\n  } catch (IOException e) { ... }\n}\nCompliant solution\npublic void doSomething(String fileName) {\n  try {\n    InputStream is = new InputStream(file);\n    byte [] buffer = new byte[1000];\n    int count = 0;\n    while (count = is.read(buffer) > 0) {\n      // ...\n    }\n  } catch (IOException e) { ... }\n}"
    },
    {
        "id": 99,
        "title": "Inappropriate regular expressions should not be used",
        "description": "Regular expressions are powerful but tricky, and even those long used to using them can make mistakes.\nThe following should not be used as regular expressions:\n. - matches any single character. Used in replaceAll , it matches everything | - normally used as an option delimiter. Used stand-alone, it matches the space between characters File.separator - matches the platform-specific file path delimiter. On Windows, this will be taken as an escape character\n. - matches any single character. Used in replaceAll , it matches everything\n| - normally used as an option delimiter. Used stand-alone, it matches the space between characters\nFile.separator - matches the platform-specific file path delimiter. On Windows, this will be taken as an escape character\nNoncompliant code example\nString str = \"/File|Name.txt\";\n\nString clean = str.replaceAll(\".\",\"\"); // Noncompliant; probably meant to remove only dot chars, but returns an empty string\nString clean2 = str.replaceAll(\"|\",\"_\"); // Noncompliant; yields _/_F_i_l_e_|_N_a_m_e_._t_x_t_\nString clean3 = str.replaceAll(File.separator,\"\"); // Noncompliant; exception on Windows\n\nString clean4 = str.replaceFirst(\".\",\"\"); // Noncompliant;\nString clean5 = str.replaceFirst(\"|\",\"_\"); // Noncompliant;\nString clean6 = str.replaceFirst(File.separator,\"\"); // Noncompliant;"
    },
    {
        "id": 100,
        "title": "\"@NonNull\" values should not be set to null",
        "description": "Fields, parameters and return values marked @NotNull , @NonNull , or @Nonnull are assumed to have non-null\nvalues and are not typically null-checked before use. Therefore setting one of these values to null , or failing to set such a class field\nin a constructor, could cause NullPointerException s at runtime.\nNoncompliant code example\npublic class MainClass {\n\n  @Nonnull\n  private String primary;\n  private String secondary;\n\n  public MainClass(String color) {\n    if (color != null) {\n      secondary = null;\n    }\n    primary = color;  // Noncompliant; \"primary\" is Nonnull but could be set to null here\n  }\n\n  public MainClass() { // Noncompliant; \"primary\" is Nonnull but is not initialized\n  }\n\n  @Nonnull\n  public String indirectMix() {\n    String mix = null;\n    return mix;  // Noncompliant; return value is Nonnull, but null is returned.\n  }"
    },
    {
        "id": 101,
        "title": "Conditionally executed code should be reachable",
        "description": "Conditional expressions which are always true or false can lead to unreachable code .\nNoncompliant code example\na = false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\nExceptions\nThis rule will not raise an issue in either of these cases:\nWhen the condition is a single final boolean\nWhen the condition is a single final boolean\nfinal boolean debug = false;\n//...\nif (debug) {\n  // Print something\n}\nWhen the condition is literally true or false .\nWhen the condition is literally true or false .\nif (true) {\n  // do something\n}\nIn these cases it is obvious the code is as intended."
    },
    {
        "id": 102,
        "title": "\"notifyAll()\" should be preferred over \"notify()\"",
        "description": "notify and notifyAll both wake up sleeping threads waiting on the object\u2019s monitor, but notify only wakes up\none single thread, while notifyAll wakes them all up. Unless you do not care which specific thread is woken up, notifyAll should be used instead.\nNoncompliant code example\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notify();  // Noncompliant\n    }\n  }\n}\nCompliant solution\nclass MyThread implements Runnable {\n  Object lock = new Object();\n\n  @Override\n  public void run() {\n    synchronized(lock) {\n      // ...\n      lock.notifyAll();\n    }\n  }\n}"
    },
    {
        "id": 103,
        "title": "Blocks should be synchronized on \"private final\" fields",
        "description": "Synchronizing on a class field synchronizes not on the field itself, but on the object assigned to it. So synchronizing on a non- final field makes it possible for the field\u2019s value to change while a thread is in a block synchronized on the old value. That would allow a second thread,\nsynchronized on the new value, to enter the block at the same time.\nThe story is very similar for synchronizing on parameters; two different threads running the method in parallel could pass two different object\ninstances in to the method as parameters, completely undermining the synchronization.\nNoncompliant code example\nprivate String color = \"red\";\n\nprivate void doSomething(){\n  synchronized(color) {  // Noncompliant; lock is actually on object instance \"red\" referred to by the color variable\n    //...\n    color = \"green\"; // other threads now allowed into this block\n    // ...\n  }\n  synchronized(new Object()) { // Noncompliant this is a no-op.\n     // ...\n  }\n}\nCompliant solution\nprivate String color = \"red\";\nprivate final Object lockObj = new Object();\n\nprivate void doSomething(){\n  synchronized(lockObj) {\n    //...\n    color = \"green\";\n    // ...\n  }\n}"
    },
    {
        "id": 104,
        "title": "Non-serializable objects should not be stored in \"javax.servlet.http.HttpSession\" instances",
        "description": "HttpSession s are managed by web servers and can be serialized and stored on disk as the server manages its memory use in a process\ncalled \"passivation\" (and later restored during \"activation\").\nEven though HttpSession does not extend Serializable , you must nonetheless assume that it will be serialized. If\nnon-serializable objects are stored in the session, serialization might fail.\nNoncompliant code example\npublic class Address {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());  // Noncompliant; Address isn't serializable\nCompliant solution\npublic class Address implements Serializable {\n  //...\n}\n\nHttpSession session = request.getSession();\nsession.setAttribute(\"address\", new Address());"
    },
    {
        "id": 105,
        "title": "Classes should not access their own subclasses during class initialization",
        "description": "Referencing a static member of a subclass from its parent during class initialization, makes the code more fragile and prone to future bugs. The\nexecution of the program will rely heavily on the order of initialization of classes and their static members.\nWhat is the potential impact?\nThis could create what is known as an \"initialization cycle\", or even a deadlock in some extreme cases. Additionally, if the order of the static\nclass members is changed, the behavior of the program might change. These issues can be very hard to diagnose so it is highly recommended to avoid\ncreating this kind of dependencies.\nNoncompliant code example\nclass Parent {\n  static int field1 = Child.method(); // Noncompliant\n  static int field2 = 42;\n\n  public static void main(String[] args) {\n    System.out.println(Parent.field1); // will display \"0\" instead of \"42\"\n  }\n}\n\nclass Child extends Parent {\n  static int method() {\n    return Parent.field2;\n  }\n}"
    },
    {
        "id": 106,
        "title": "\"wait(...)\" should be used instead of \"Thread.sleep(...)\" when a lock is held",
        "description": "In a multithreaded environment, a thread may need to wait for a particular condition to become true. One way of pausing execution in Java is Thread.sleep(\u2026\u200b) .\nIf a thread that holds a lock calls Thread.sleep(\u2026\u200b) , no other thread can acquire said lock. This can lead to performance and\nscalability issues, in the worst case leading to deadlocks."
    },
    {
        "id": 107,
        "title": "Printf-style format strings should not lead to unexpected behavior at runtime",
        "description": "Because printf -style format strings are interpreted at runtime, rather than validated by the Java compiler, they can contain errors\nthat lead to unexpected behavior or runtime errors. This rule statically validates the good behavior of printf -style formats when calling\nthe format(...) methods of java.util.Formatter , java.lang.String , java.io.PrintStream , MessageFormat , and java.io.PrintWriter classes and the printf(...) methods of java.io.PrintStream or java.io.PrintWriter classes.\nNoncompliant code example\nString.format(\"The value of my integer is %d\", \"Hello World\");  // Noncompliant; an 'int' is expected rather than a String\nString.format(\"Duke's Birthday year is %tX\", c);  //Noncompliant; X is not a supported time conversion character\nString.format(\"Display %0$d and then %d\", 1);   //Noncompliant; arguments are numbered starting from 1\nString.format(\"Not enough arguments %d and %d\", 1);  //Noncompliant; the second argument is missing\nString.format(\"%< is equals to %d\", 2);   //Noncompliant; the argument index '<' refers to the previous format specifier but there isn't one\n\nMessageFormat.format(\"Result {1}.\", value); // Noncompliant; Not enough arguments. (first element is {0})\nMessageFormat.format(\"Result {{0}.\", value); // Noncompliant; Unbalanced number of curly brace (single curly braces should be escaped)\nMessageFormat.format(\"Result ' {0}\", value); // Noncompliant; Unbalanced number of quotes (single quote must be escaped)\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1}!\", 14); // Noncompliant - Not enough arguments.\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\"); // Noncompliant - Not enough arguments.\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\"); // Noncompliant - Not enough arguments.\nCompliant solution\nString.format(\"The value of my integer is %d\", 3);\nString.format(\"Duke's Birthday year is %tY\", c);\nString.format(\"Display %1$d and then %d\", 1);\nString.format(\"Not enough arguments %d and %d\", 1, 2);\nString.format(\"%d is equals to %<\", 2);\n\nMessageFormat.format(\"Result {0}.\", value);\nMessageFormat.format(\"Result {0} & {1}.\", value, value);\nMessageFormat.format(\"Result {0}.\", myObject);\n\njava.util.logging.Logger logger;\nlogger.log(java.util.logging.Level.SEVERE, \"Result {1},{2}!\", 14, 2);\n\norg.slf4j.Logger slf4jLog;\norg.slf4j.Marker marker;\n\nslf4jLog.debug(marker, \"message {}\", 1);\n\norg.apache.logging.log4j.Logger log4jLog;\nlog4jLog.debug(\"message {}\", 1);"
    },
    {
        "id": 108,
        "title": "\"Object.wait()\", \"Object.notify()\" and \"Object.notifyAll()\" should only be called from synchronized code",
        "description": "The Object.wait(\u2026\u200b) , Object.notify() and Object.notifyAll() methods are used in multithreaded environments\nto coordinate interdependent tasks that are performed by different threads. These methods are not thread-safe and by contract, they require the\ninvoking Thread to own the object\u2019s monitor. If a thread invokes one of these methods without owning the object\u2019s monitor an IllegalMonitorStateException is thrown."
    },
    {
        "id": 109,
        "title": "\"Iterator.next()\" methods should throw \"NoSuchElementException\"",
        "description": "The java.util.Iterator.next() method must throw a NoSuchElementException when there are no more elements in the\niteration. Any other behavior is non-compliant with the API contract and may cause unexpected behavior for users.\nNoncompliant code example\npublic class MyIterator implements Iterator<String> {\n  public String next() {\n    if (!hasNext()) {\n      return null;\n    }\n    // ...\n  }\n}\nCompliant solution\npublic class MyIterator implements Iterator<String> {\n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    // ...\n  }\n}"
    },
    {
        "id": 110,
        "title": "Null pointers should not be dereferenced",
        "description": "A reference to null should never be dereferenced/accessed. Doing so will cause a NullPointerException to be thrown. At\nbest, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would be useful to an attacker, or\nit could allow an attacker to bypass security measures.\nNote that when they are present, this rule takes advantage of nullability annotations, like @CheckForNull or @Nonnull ,\ndefined in JSR-305 to understand which values can be null or not. @Nonnull will be\nignored if used on the parameter of the equals method, which by contract should always work with null."
    },
    {
        "id": 111,
        "title": "Loop conditions should be true at least once",
        "description": "A for loop is a fundamental programming construct\nused to execute a block of code repeatedly. However, if the loop\u2019s condition is false before the first iteration, the loop will never execute.\nfor (int i = 0; i < 0; i++) {  // Noncompliant: the condition is always false, and the loop will never execute\n    // ...\n}\nRewrite the loop to ensure the condition evaluates to true at least once.\nfor (int i = 0; i < 10; i++) {  // Compliant: the condition is true at least once, the loop will execute\n    // ...\n}\nThis bug has the potential to cause unexpected outcomes as the loop might contain critical code that needs to be executed."
    },
    {
        "id": 112,
        "title": "A \"for\" loop update clause should move the counter in the right direction",
        "description": "A for loop with a counter moving away from the end of the specified range is likely a programming mistake.\nIf the intention is to iterate over the specified range, this differs from what the loop does because the counter moves in the wrong direction.\nIf the intention is to have an infinite loop or a loop terminated only by a break statement, there are two problems:\nThe loop condition is not infinite because the counter variable will eventually overflow and fulfill the condition. This can take a long time,\n  depending on the data type of the counter.\nAn infinite loop terminated by a break statement should be implemented using a while or do while loop to make the developer\u2019s intention clear to the reader."
    },
    {
        "id": 113,
        "title": "Methods \"wait(...)\", \"notify()\" and \"notifyAll()\" should not be called on Thread instances",
        "description": "In Java, the Thread class represents a thread of execution. Synchronization between threads is typically achieved using objects or\nshared resources.\nThe methods wait(\u2026\u200b) , notify() , and notifyAll() are related to the underlying object\u2019s monitor and are\ndesigned to be called on objects that act as locks or monitors for synchronization. These methods are available on Java Object and,\ntherefore, automatically inherited by all objects, including Thread.\nCalling these methods on a Thread may corrupt the behavior of the JVM, which relies on them to change the state of the thread\n( BLOCKED, WAITING, \u2026\u200b).\nNoncompliant code example\nThread myThread = new Thread(new RunnableJob());\n...\nmyThread.wait(); // Noncompliant"
    },
    {
        "id": 114,
        "title": "Methods with Spring proxying annotations should be public",
        "description": "Marking a non-public method @Async or @Transactional is misleading because Spring does not recognize non-public methods,\nand so makes no provision for their proper invocation. Nor does Spring make provision for the methods invoked by the method it called.\nTherefore marking a private method, for instance, @Transactional can only result in a runtime error or exception if the method is annotated as\n@Transactional."
    },
    {
        "id": 115,
        "title": "Methods should not call same-class methods with incompatible \"@Transactional\" values",
        "description": "Transactional methods have a propagation type parameter in the @Transaction annotation that specifies the requirements about the transactional\ncontext in which the method can be called and how it creates, appends, or suspends an ongoing transaction.\nWhen an instance that contains transactional methods is injected, Spring uses proxy objects to wrap these methods with the actual transaction\ncode.\nHowever, if a transactional method is called from another method in the same class, the this argument is used as the receiver instance\ninstead of the injected proxy object, which bypasses the wrapper code. This results in specific transitions from one transactional method to another,\nwhich are not allowed:\nnon- @Transactional\nMANDATORY, NESTED, REQUIRED, REQUIRES_NEW\nMANDATORY\nNESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW\nNESTED\nNESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW\nNEVER\nMANDATORY, NESTED, REQUIRED, REQUIRES_NEW\nNOT_SUPPORTED\nMANDATORY, NESTED, REQUIRED, REQUIRES_NEW\nREQUIRED or @Transactional\nNESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW\nREQUIRES_NEW\nNESTED, NEVER, NOT_SUPPORTED, REQUIRES_NEW\nSUPPORTS\nMANDATORY, NESTED, NEVER, NOT_SUPPORTED, REQUIRED, REQUIRES_NEW"
    },
    {
        "id": 116,
        "title": "Servlets should not have mutable instance fields",
        "description": "The processHttpRequest method and methods called from it can be executed by multiple threads within the same servlet instance, and\nstate changes to the instance caused by these methods are, therefore, not threadsafe.\nThis is due to the servlet container creating only one instance of each servlet ( javax.servlet.http.HttpServlet ) and attaching a\ndedicated thread to each incoming HTTP request. The same problem exists for org.apache.struts.action.Action but with different\nmethods.\nTo prevent unexpected behavior, avoiding mutable states in servlets is recommended. Mutable instance fields should either be refactored into local\nvariables or made immutable by declaring them final .\nExceptions\nFields annotated with @javax.inject.Inject , @javax.ejb.EJB , @org.springframework.beans.factory.annotation.Autowired , @javax.annotation.Resource Fields initialized in init() or init(ServletConfig config) methods\nFields annotated with @javax.inject.Inject , @javax.ejb.EJB , @org.springframework.beans.factory.annotation.Autowired , @javax.annotation.Resource\nFields initialized in init() or init(ServletConfig config) methods"
    },
    {
        "id": 117,
        "title": "\"toString()\" and \"clone()\" methods should not return null",
        "description": "Calling toString() or clone() on an object should always return a string or an object. Returning null instead contravenes the method\u2019s implicit contract.\nNoncompliant code example\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return null; // Noncompliant\n  } else {\n    // ...\nCompliant solution\npublic String toString () {\n  if (this.collection.isEmpty()) {\n    return \"\";\n  } else {\n    // ..."
    },
    {
        "id": 118,
        "title": "Locks should be released on all paths",
        "description": "If a lock is acquired and released within a method, then it must be released along all execution paths of that method.\nFailing to do so will expose the conditional locking logic to the method\u2019s callers and hence be deadlock-prone.\nNoncompliant code example\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    lock.lock(); // Noncompliant\n    if (isInitialized()) {\n      // ...\n      lock.unlock();\n    }\n  }\n}\nCompliant solution\npublic class MyClass {\n  public void doSomething() {\n    Lock lock = new Lock();\n    if (isInitialized()) {\n      lock.lock();\n      // ...\n      lock.unlock();\n    }\n  }\n}"
    },
    {
        "id": 119,
        "title": "\".equals()\" should not be used to test the values of \"Atomic\" classes",
        "description": "The equals method in AtomicInteger and AtomicLong returns true only if two instances are\nidentical, not if they represent the same number value.\nThis is because equals is not part of the API contract of these classes, and they do not override the method inherited from java.lang.Object . Although both classes implement the Number interface, assertions about equals comparing\nnumber values are not part of that interface either. Only the API contract of implementing classes like Integer , Long , Float , BigInteger , etc., provides such assertions."
    },
    {
        "id": 120,
        "title": "Return values from functions without side effects should not be ignored",
        "description": "When the call to a function doesn\u2019t have any side effects, what is the point of making the call if the results are ignored? In such case, either\nthe function call is useless and should be dropped or the source code doesn\u2019t behave as expected.\nTo prevent generating any false-positives, this rule triggers an issue only on the following predefined list of immutable classes in the Java API\n:\njava.lang.String java.lang.Boolean java.lang.Integer java.lang.Double java.lang.Float java.lang.Byte java.lang.Character java.lang.Short java.lang.StackTraceElement java.time.DayOfWeek java.time.Duration java.time.Instant java.time.LocalDate java.time.LocalDateTime java.time.LocalTime java.time.Month java.time.MonthDay java.time.OffsetDateTime java.time.OffsetTime java.time.Period java.time.Year java.time.YearMonth java.time.ZonedDateTime java.math.BigInteger java.math.BigDecimal java.util.Optional\njava.lang.String\njava.lang.Boolean\njava.lang.Integer\njava.lang.Double\njava.lang.Float\njava.lang.Byte\njava.lang.Character\njava.lang.Short\njava.lang.StackTraceElement\njava.time.DayOfWeek\njava.time.Duration\njava.time.Instant\njava.time.LocalDate\njava.time.LocalDateTime\njava.time.LocalTime\njava.time.Month\njava.time.MonthDay\njava.time.OffsetDateTime\njava.time.OffsetTime\njava.time.Period\njava.time.Year\njava.time.YearMonth\njava.time.ZonedDateTime\njava.math.BigInteger\njava.math.BigDecimal\njava.util.Optional\nAs well as methods of the following classes:\njava.util.Collection : size() isEmpty() contains(...) containsAll(...) iterator() toArray() java.util.Map : size() isEmpty() containsKey(...) containsValue(...) get(...) getOrDefault(...) keySet() entrySet() values() java.util.stream.Stream toArray reduce collect min max count anyMatch allMatch noneMatch findFirst findAny toList\njava.util.Collection : size() isEmpty() contains(...) containsAll(...) iterator() toArray()\nsize() isEmpty() contains(...) containsAll(...) iterator() toArray()\nsize()\nisEmpty()\ncontains(...)\ncontainsAll(...)\niterator()\ntoArray()\njava.util.Map : size() isEmpty() containsKey(...) containsValue(...) get(...) getOrDefault(...) keySet() entrySet() values()\nsize() isEmpty() containsKey(...) containsValue(...) get(...) getOrDefault(...) keySet() entrySet() values()\nsize()\nisEmpty()\ncontainsKey(...)\ncontainsValue(...)\nget(...)\ngetOrDefault(...)\nkeySet()\nentrySet()\nvalues()\njava.util.stream.Stream toArray reduce collect min max count anyMatch allMatch noneMatch findFirst findAny toList\ntoArray reduce collect min max count anyMatch allMatch noneMatch findFirst findAny toList\ntoArray\nreduce\ncollect\nmin\nmax\ncount\nanyMatch\nallMatch\nnoneMatch\nfindFirst\nfindAny\ntoList\nNoncompliant code example\npublic void handle(String command){\n  command.toLowerCase(); // Noncompliant; result of method thrown away\n  ...\n}\nCompliant solution\npublic void handle(String command){\n  String formattedCommand = command.toLowerCase();\n  ...\n}\nExceptions\nThis rule will not raise an issue when both these conditions are met:\nThe method call is in a try block with an associated catch clause. The method name starts with \"parse\", \"format\", \"decode\" or \"valueOf\" or the method is String.getBytes(Charset) .\nThe method call is in a try block with an associated catch clause.\nThe method name starts with \"parse\", \"format\", \"decode\" or \"valueOf\" or the method is String.getBytes(Charset) .\nprivate boolean textIsInteger(String textToCheck) {\n\n    try {\n        Integer.parseInt(textToCheck, 10); // OK\n        return true;\n    } catch (NumberFormatException ignored) {\n        return false;\n    }\n}"
    },
    {
        "id": 121,
        "title": "\"compareTo\" results should not be checked for specific values",
        "description": "Assuming that a comparator or compareTo method always returns -1 or 1 if the first operand is less than or greater than the second is\nincorrect.\nThe specifications for both methods, Comparator.compare and Comparable.compareTo , state that their return value is \"a\nnegative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.\" Even if a specific\ncomparator always returns -1, 0, or 1, this is only an implementation detail, not the API contract developers can rely on."
    },
    {
        "id": 122,
        "title": "Recursion should not be infinite",
        "description": "Recursion is a technique to solve a computational problem by splitting it into smaller problems. A method is recursive, if it splits its input into\nsmaller instances and calls itself on these instances. This continues until a smallest input, a base case , is reached that can not be split\nfurther. Similarly, recursion can also occur when multiple methods invoke each other.\nRecursion is a useful tool, but it must be used carefully. Recursive methods need to detect base cases and end recursion with a return statement. When this is not the case, recursion will continue until the stack overflows and the program crashes due to a StackOverflowError .\nWhat is the potential impact?\nIssues of this type interrupt the normal execution of a program, causing it to crash or putting it into an inconsistent state. Therefore, this\nissue might impact the availability and reliability of your application, or even result in data loss."
    },
    {
        "id": 123,
        "title": "Loops should not be infinite",
        "description": "An infinite loop will never end while the program runs, meaning you have to kill the program to get out of the loop. Every loop should have an end\ncondition, whether by meeting the loop\u2019s termination condition or via a break statement.\nNoncompliant code example\nfor (;;) {  // Noncompliant; end condition omitted\n  // ...\n}\nint j;\nwhile (true) { // Noncompliant; end condition omitted\n  j++;\n}\nint k;\nboolean b = true;\nwhile (b) { // Noncompliant; b never written to in loop\n  k++;\n}\nCompliant solution\nint j;\nwhile (true) { // reachable end condition added\n  j++;\n  if (j  == Integer.MIN_VALUE) {  // true at Integer.MAX_VALUE +1\n    break;\n  }\n}\nint k;\nboolean b = true;\nwhile (b) {\n  k++;\n  b = k < Integer.MAX_VALUE;\n}"
    },
    {
        "id": 124,
        "title": "Math operands should be cast before assignment",
        "description": "When arithmetic is performed on integers, the result will always be an integer. You can assign that result to a long , double , or float with automatic type conversion, but having started as an int or long , the result\nwill likely not be what you expect.\nFor instance, if the result of int division is assigned to a floating-point variable, precision will have been lost before the\nassignment. Likewise, if the result of multiplication is assigned to a long , it may have already overflowed before the assignment.\nIn either case, the result will not be what was expected. Instead, at least one operand should be cast or promoted to the final type before the\noperation takes place.\nNoncompliant code example\nfloat twoThirds = 2/3; // Noncompliant; int division. Yields 0.0\nlong millisInYear = 1_000*3_600*24*365; // Noncompliant; int multiplication. Yields 1471228928\nlong bigNum = Integer.MAX_VALUE + 2; // Noncompliant. Yields -2147483647\nlong bigNegNum =  Integer.MIN_VALUE-1; //Noncompliant, gives a positive result instead of a negative one.\nDate myDate = new Date(seconds * 1_000); //Noncompliant, won't produce the expected result if seconds > 2_147_483\n...\npublic long compute(int factor){\n  return factor * 10_000;  //Noncompliant, won't produce the expected result if factor > 214_748\n}\n\npublic float compute2(long factor){\n  return factor / 123;  //Noncompliant, will be rounded to closest long integer\n}\nCompliant solution\nfloat twoThirds = 2f/3; // 2 promoted to float. Yields 0.6666667\nlong millisInYear = 1_000L*3_600*24*365; // 1000 promoted to long. Yields 31_536_000_000\nlong bigNum = Integer.MAX_VALUE + 2L; // 2 promoted to long. Yields 2_147_483_649\nlong bigNegNum =  Integer.MIN_VALUE-1L; // Yields -2_147_483_649\nDate myDate = new Date(seconds * 1_000L);\n...\npublic long compute(int factor){\n  return factor * 10_000L;\n}\n\npublic float compute2(long factor){\n  return factor / 123f;\n}\nor\nfloat twoThirds = (float)2/3; // 2 cast to float\nlong millisInYear = (long)1_000*3_600*24*365; // 1_000 cast to long\nlong bigNum = (long)Integer.MAX_VALUE + 2;\nlong bigNegNum =  (long)Integer.MIN_VALUE-1;\nDate myDate = new Date((long)seconds * 1_000);\n...\npublic long compute(long factor){\n  return factor * 10_000;\n}\n\npublic float compute2(float factor){\n  return factor / 123;\n}"
    },
    {
        "id": 125,
        "title": "Ints and longs should not be shifted by zero or more than their number of bits-1",
        "description": "Since an int is a 32-bit variable, shifting by more than +/-31 is confusing at best and an error at worst. When the runtime shifts\n32-bit integers, it uses the lowest 5 bits of the shift count operand. In other words, shifting an int by 32 is the same as shifting it\nby 0, and shifting it by 33 is the same as shifting it by 1.\nSimilarly, when shifting 64-bit integers, the runtime uses the lowest 6 bits of the shift count operand and shifting long by 64 is the\nsame as shifting it by 0, and shifting it by 65 is the same as shifting it by 1."
    },
    {
        "id": 126,
        "title": "Child class methods named for parent class methods should be overrides",
        "description": "When a method in a child class has the same signature as a method in a parent class, it is assumed to be an override. However, that\u2019s not the case\nwhen:\nthe parent class method is static and the child class method is not. the arguments or return types of the child method are in different packages than those of the parent method. the parent class method is private .\nthe parent class method is static and the child class method is not.\nthe arguments or return types of the child method are in different packages than those of the parent method.\nthe parent class method is private .\nTypically, these things are done unintentionally; the private parent class method is overlooked, the static keyword in the parent\ndeclaration is overlooked, or the wrong class is imported in the child. But if the intent is truly for the child class method to be different, then\nthe method should be renamed to prevent confusion.\nNoncompliant code example\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport fruit.Pear;\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // Noncompliant; this is not an override\n    // ...\n  }\n\n\n  public void doSomethingElse() {  // Noncompliant; parent method is static\n    //...\n  }\n}\nCompliant solution\n// Parent.java\nimport computer.Pear;\npublic class Parent {\n\n  public void doSomething(Pear p) {\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}\n\n// Child.java\nimport computer.Pear;  // import corrected\npublic class Child extends Parent {\n\n  public void doSomething(Pear p) {  // true override (see import)\n    //,,,\n  }\n\n  public static void doSomethingElse() {\n    //...\n  }\n}"
    },
    {
        "id": 127,
        "title": "Inappropriate \"Collection\" calls should not be made",
        "description": "The java.util.Collection type and its subtypes provide methods to access and modify collections such as Collection.remove(Object\no) and Collection.contains(Object o) . Some of these methods accept arguments of type java.lang.Object and will\ncompare said argument with objects already in the collection.\nIf the actual type of the argument is unrelated to the type of object contained in the collection, these methods will always return false , null , or -1 . This behavior is most likely unintended and can be indicative of a design issue.\nThis rule raises an issue when the type of the argument provided to one of the following methods is unrelated to the type used for the collection\ndeclaration:\nCollection.remove(Object o) Collection.removeAll(Collection<?>) Collection.contains(Object o) List.indexOf(Object o) List.lastIndexOf(Object o) Map.containsKey(Object key) Map.containsValue(Object value) Map.get(Object key) Map.getOrDefault(Object key, V defaultValue) Map.remove(Object key) Map.remove(Object key, Object value)\nCollection.remove(Object o)\nCollection.removeAll(Collection<?>)\nCollection.contains(Object o)\nList.indexOf(Object o)\nList.lastIndexOf(Object o)\nMap.containsKey(Object key)\nMap.containsValue(Object value)\nMap.get(Object key)\nMap.getOrDefault(Object key, V defaultValue)\nMap.remove(Object key)\nMap.remove(Object key, Object value)"
    },
    {
        "id": 128,
        "title": "Double-checked locking should not be used",
        "description": "Double-checked locking is the practice of checking a lazy-initialized object\u2019s state both before and after a synchronized block is\nentered to determine whether to initialize the object. In early JVM versions, synchronizing entire methods was not performant, which sometimes caused\nthis practice to be used in its place.\nApart from float and int types, this practice does not work reliably in a platform-independent manner without additional\nsynchronization of mutable instances. Using double-checked locking for the lazy initialization of any other type of primitive or mutable object risks\na second thread using an uninitialized or partially initialized member while the first thread is still creating it. The results can be unexpected,\npotentially even causing the application to crash."
    },
    {
        "id": 129,
        "title": "\"compareTo\" should not return \"Integer.MIN_VALUE\"",
        "description": "The Comparable.compareTo method returns a negative integer, zero, or a positive integer to indicate whether the object is less than,\nequal to, or greater than the parameter. The sign of the return value or whether it is zero is what matters, not its magnitude.\nReturning a positive or negative constant value other than the basic ones (-1, 0, or 1) provides no additional information to the caller. Moreover,\nit could potentially confuse code readers who are trying to understand its purpose."
    },
    {
        "id": 130,
        "title": "Math should not be performed on floats",
        "description": "For small numbers, float math has enough precision to yield the expected value, but for larger numbers, it does not. BigDecimal is the best alternative, but if a primitive is required, use a double .\nNoncompliant code example\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nfloat c = a + b; // Noncompliant; yields 1.6777216E7 not 1.6777217E7\n\ndouble d = a + b; // Noncompliant; addition is still between 2 floats\nCompliant solution\nfloat a = 16777216.0f;\nfloat b = 1.0f;\nBigDecimal c = BigDecimal.valueOf(a).add(BigDecimal.valueOf(b));\n\ndouble d = (double)a + (double)b;\nExceptions\nThis rule doesn\u2019t raise an issue when the mathematical expression is only used to build a string.\nSystem.out.println(\"[\"+getName()+\"] \" +\n           \"\\n\\tMax time to retrieve connection:\"+(max/1000f/1000f)+\" ms.\");"
    },
    {
        "id": 131,
        "title": "\"equals\" methods should be symmetric and work for subclasses",
        "description": "A key facet of the equals contract is that if a.equals(b) then b.equals(a) , i.e. that the relationship is\nsymmetric.\nUsing instanceof breaks the contract when there are subclasses, because while the child is an instanceof the parent, the\nparent is not an instanceof the child. For instance, assume that Raspberry extends Fruit and adds some fields (requiring a\nnew implementation of equals ):\nFruit fruit = new Fruit();\nRaspberry raspberry = new Raspberry();\n\nif (raspberry instanceof Fruit) { ... } // true\nif (fruit instanceof Raspberry) { ... } // false\nIf similar instanceof checks were used in the classes' equals methods, the symmetry principle would be broken:\nraspberry.equals(fruit); // false\nfruit.equals(raspberry); //true\nAdditionally, non final classes shouldn\u2019t use a hardcoded class name in the equals method because doing so breaks the\nmethod for subclasses. Instead, make the comparison dynamic.\nFurther, comparing to an unrelated class type breaks the contract for that unrelated type, because while thisClass.equals(unrelatedClass) can return true, unrelatedClass.equals(thisClass) will not.\nNoncompliant code example\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (Fruit.class == obj.getClass()) { // Noncompliant; broken for child classes\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    if (obj instanceof Fruit ) {  // Noncompliant; broken for child classes\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    else if (obj instanceof Season) { // Noncompliant; symmetry broken for Season class\n      // ...\n    }\n    //...\nCompliant solution\npublic class Fruit extends Food {\n  private Season ripe;\n\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (this.getClass() == obj.getClass()) {\n      return ripe.equals(((Fruit)obj).getRipe());\n    }\n    return false;\n}"
    },
    {
        "id": 132,
        "title": "Unnecessary equality checks should not be made",
        "description": "Comparisons of dissimilar types will always return false. The comparison and all its dependent code can simply be removed. This includes:\ncomparing an object with null comparing an object with an unrelated primitive (E.G. a string with an int) comparing unrelated classes comparing an unrelated class and interface comparing unrelated interface types comparing an array to a non-array comparing two arrays\ncomparing an object with null\ncomparing an object with an unrelated primitive (E.G. a string with an int)\ncomparing unrelated classes\ncomparing an unrelated class and interface\ncomparing unrelated interface types\ncomparing an array to a non-array\ncomparing two arrays\nSpecifically in the case of arrays, since arrays don\u2019t override Object.equals() , calling equals on two arrays is the same\nas comparing their addresses. This means that array1.equals(array2) is equivalent to array1==array2 .\nHowever, some developers might expect Array.equals(Object obj) to do more than a simple memory address comparison, comparing for\ninstance the size and content of the two arrays. Instead, the == operator or Arrays.equals(array1, array2) should always be\nused with arrays.\nNoncompliant code example\ninterface KitchenTool { ... };\ninterface Plant {...}\n\npublic class Spatula implements KitchenTool { ... }\npublic class Tree implements Plant { ...}\n//...\n\nSpatula spatula = new Spatula();\nKitchenTool tool = spatula;\nKitchenTool [] tools = {tool};\n\nTree tree = new Tree();\nPlant plant = tree;\nTree [] trees = {tree};\n\n\nif (spatula.equals(tree)) { // Noncompliant; unrelated classes\n  // ...\n}\nelse if (spatula.equals(plant)) { // Noncompliant; unrelated class and interface\n  // ...\n}\nelse if (tool.equals(plant)) { // Noncompliant; unrelated interfaces\n  // ...\n}\nelse if (tool.equals(tools)) { // Noncompliant; array & non-array\n  // ...\n}\nelse if (trees.equals(tools)) { // Noncompliant; incompatible arrays\n  // ...\n}\nelse if (tree.equals(null)) { // Noncompliant\n  // ...\n}"
    },
    {
        "id": 133,
        "title": "Dissimilar primitive wrappers should not be used with the ternary operator without explicit casting",
        "description": "Using boxed values in a ternary operator does not simply return one operand or the other based on the condition. Instead, the values are unboxed\nand coerced to a common type, which can result in a loss of precision when converting one operand from int to float or from long to double .\nWhile this behavior is expected for arithmetic operations, it may be unexpected for the ternary operator. To avoid confusion or unexpected\nbehavior, cast to a compatible type explicitly."
    },
    {
        "id": 134,
        "title": "Unnecessary boxing and unboxing should be avoided",
        "description": "Boxing is the process of putting a primitive value into a wrapper object, such as creating an Integer to hold an int value. Unboxing is the process of retrieving the primitive value from such an object. Since the original value is unchanged during boxing and\nunboxing, there is no point in doing either when not needed.\nInstead, you should rely on Java\u2019s implicit boxing/unboxing to convert from the primitive type to the wrapper type and vice versa, for better\nreadability.\nNoncompliant code example\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = Double.valueOf(d).intValue(); // Noncompliant; should be replaced with a simple cast\n\n  examinePrimitiveInt(boxedInt.intValue()); // Noncompliant; unnecessary unboxing\n  examinePrimitiveInt(Integer.valueOf(primitiveInt));  // Noncompliant; boxed int will be auto-unboxed\n\n  examineBoxedInteger(Integer.valueOf(primitiveInt)); // Noncompliant; unnecessary boxing\n  examineBoxedInteger(boxedInt.intValue()); // Noncompliant; unboxed int will be autoboxed\n}\nCompliant solution\npublic void examinePrimitiveInt(int a) {\n  //...\n}\n\npublic void examineBoxedInteger(Integer a) {\n  // ...\n}\n\npublic void func() {\n  int primitiveInt = 0;\n  Integer boxedInt = Integer.valueOf(0);\n  double d = 1.0;\n\n  int dIntValue = (int) d;\n\n  examinePrimitiveInt(primitiveInt);\n  examinePrimitiveInt(boxedInt);\n\n  examineBoxedInteger(primitiveInt);\n  examineBoxedInteger(boxedInt);\n}"
    },
    {
        "id": 135,
        "title": "\"runFinalizersOnExit\" should not be called",
        "description": "Enabling runFinalizersOnExit is unsafe as it might result in erratic behavior and deadlocks on application exit.\nIndeed, finalizers might be force-called on live objects while other threads are concurrently manipulating them.\nInstead, if you want to execute something when the virtual machine begins its shutdown sequence, you should attach a shutdown hook.\nNoncompliant code example\npublic static void main(String [] args) {\n  System.runFinalizersOnExit(true);  // Noncompliant\n}\n\nprotected void finalize(){\n  doShutdownOperations();\n}\nCompliant solution\npublic static void main(String [] args) {\n  Thread myThread = new Thread( () -> { doShutdownOperations(); });\n  Runtime.getRuntime().addShutdownHook(myThread);\n}"
    },
    {
        "id": 136,
        "title": "\"InterruptedException\" and \"ThreadDeath\" should not be ignored",
        "description": "If an InterruptedException or a ThreadDeath error is not handled properly, the information that the thread was\ninterrupted will be lost. Handling this exception means either to re-throw it or manually re-interrupt the current thread by calling Thread.interrupt() . Simply logging the exception is not sufficient and counts as ignoring it. Between the moment the exception is caught\nand handled, is the right time to perform cleanup operations on the method\u2019s state, if needed.\nWhat is the potential impact?\nFailing to interrupt the thread (or to re-throw) risks delaying the thread shutdown and losing the information that the thread was interrupted -\nprobably without finishing its task.\nNoncompliant code example\npublic void run () {\n  try {\n    /*...*/\n  } catch (InterruptedException e) { // Noncompliant; logging is not enough\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n  }\n}\nCompliant solution\npublic void run () {\n  try {\n    /* ... */\n  } catch (InterruptedException e) { // Compliant; the interrupted state is restored\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before interrupting  */\n    Thread.currentThread().interrupt();\n  }\n}\n\npublic void run () {\n  try {\n    /* ... */\n  } catch (ThreadDeath e) { // Compliant; the error is being re-thrown\n    LOGGER.log(Level.WARN, \"Interrupted!\", e);\n    /* Clean up whatever needs to be handled before re-throwing  */\n    throw e;\n  }\n}"
    },
    {
        "id": 137,
        "title": "Classes that don't define \"hashCode()\" should not be used in hashes",
        "description": "Because Object implements hashCode , any Java class can be put into a hash structure. However, classes that define equals(Object) but not hashCode() aren\u2019t truly hash-able because instances that are equivalent according to the equals method can return different hashes.\nNoncompliant code example\npublic class Student {  // no hashCode() method; not hash-able\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n}\n\npublic class School {\n  private Map<Student, Integer> studentBody = // okay so far\n          new HashTable<Student, Integer>(); // Noncompliant\n\n  // ...\nCompliant solution\npublic class Student {  // has hashCode() method; hash-able\n  // ...\n\n  public boolean equals(Object o) {\n    // ...\n  }\n  public int hashCode() {\n    // ...\n  }\n}\n\npublic class School {\n  private Map<Student, Integer> studentBody = new HashTable<Student, Integer>();\n\n  // ..."
    },
    {
        "id": 138,
        "title": "Classes extending java.lang.Thread should provide a specific \"run\" behavior",
        "description": "The default implementation of java.lang.Thread 's run will only perform a task passed as a Runnable . If no Runnable has been provided at construction time, then the thread will not perform any action.\nWhen extending java.lang.Thread , you should override the run method or pass a Runnable target to the\nconstructor of java.lang.Thread .\nNoncompliant code example\npublic class MyThread extends Thread { // Noncompliant\n  public void doSomething() {\n    System.out.println(\"Hello, World!\");\n  }\n}"
    },
    {
        "id": 139,
        "title": "\"Double.longBitsToDouble\" should take \"long\" as argument",
        "description": "Double.longBitsToDouble converts the bit pattern into its corresponding floating-point representation. The method expects a 64-bit\nlong argument to interpret the bits as a double value correctly.\nWhen the argument is a smaller data type, the cast to long may lead to a different value than expected due to the interpretation of\nthe most significant bit, which, in turn, results in Double.longBitsToDouble returning an incorrect value.\nNoncompliant code example\nint i = 0x80003800;\nDouble.longBitsToDouble(i);   // Noncompliant - NaN\nCompliant solution\nlong i = 0x80003800L;\nDouble.longBitsToDouble(i);   // Compliant - 1.0610049784E-314"
    },
    {
        "id": 140,
        "title": "Values should not be uselessly incremented",
        "description": "A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\nNoncompliant code example\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i = i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\nCompliant solution\npublic int pickNumber() {\n  int i = 0;\n  int j = 0;\n\n  i++;\n  return ++j;\n}"
    },
    {
        "id": 141,
        "title": "\"ScheduledThreadPoolExecutor\" should not have 0 core threads",
        "description": "ThreadPoolExecutor is an object that efficiently manages and controls the execution of multiple tasks in a thread pool. A thread pool\nis a collection of pre-initialized threads ready to execute tasks. Instead of creating a new thread for each task, which can be costly in terms of\nsystem resources, a thread pool reuses existing threads.\njava.util.concurrent.ScheduledThreadPoolExecutor is an extension of ThreadPoolExecutor that can additionally schedule\ncommands to run after a given delay or to execute periodically.\nScheduledThreadPoolExecutor 's pool is sized with corePoolSize , so setting corePoolSize to zero means the\nexecutor will have no threads and run nothing. corePoolSize should have a value greater than zero and valid for your tasks.\nThis rule detects instances where corePoolSize is set to zero via its setter or the object constructor.\nNoncompliant code example\npublic void do(){\n\n  int poolSize = 5; // value greater than 0\n\n  ScheduledThreadPoolExecutor threadPool1 = new ScheduledThreadPoolExecutor(0); // Noncompliant\n\n  ScheduledThreadPoolExecutor threadPool2 = new ScheduledThreadPoolExecutor(poolSize);\n  threadPool2.setCorePoolSize(0);  // Noncompliant\n}"
    },
    {
        "id": 142,
        "title": "String operations with predictable outcomes should be avoided",
        "description": "Operations performed on a string with predictable outcomes should be avoided. For example:\nchecking if a string contains itself comparing a string with itself matching a string against itself creating a substring from 0 to the end of the string creating a substring from the end of the string replacing a string with itself replacing a substring with the exact substring\nchecking if a string contains itself\ncomparing a string with itself\nmatching a string against itself\ncreating a substring from 0 to the end of the string\ncreating a substring from the end of the string\nreplacing a string with itself\nreplacing a substring with the exact substring"
    },
    {
        "id": 143,
        "title": "\"Random\" objects should be reused",
        "description": "Creating a new Random object each time a random value is needed is inefficient and may produce numbers that are not random, depending\non the JDK. For better efficiency and randomness, create a single Random , store it, and reuse it.\nThe Random() constructor tries to set the seed with a distinct value every time. However, there is no guarantee that the seed will be\nrandomly or uniformly distributed. Some JDK will use the current time as seed, making the generated numbers not random.\nThis rule finds cases where a new Random is created each time a method is invoked.\nExceptions\nThis rule doesn\u2019t apply to classes that use a Random in their constructors or the static main function and nowhere\nelse."
    },
    {
        "id": 144,
        "title": "\"writeObject\" argument must implement \"Serializable\"",
        "description": "Serialization is a platform-independent mechanism for writing the state of an object into a byte-stream. For serializing the object, we call the writeObject() method of java.io.ObjectOutputStream class. Only classes that implement Serializable or extend a\nclass that does it can successfully be serialized (or de-serialized).\nAttempting to write a class with the writeObject method of the ObjectOutputStream class that does not implement Serializable or extends a class that implements it, will throw an IOException ."
    },
    {
        "id": 145,
        "title": "\"hashCode\" and \"toString\" should not be called on array instances",
        "description": "The purpose of the hashCode method is to return a hash code based on the contents of the object. Similarly, the purpose of the toString method is to provide a textual representation of the object\u2019s contents.\nCalling hashCode() and toString() directly on array instances should be avoided because the default implementations\nprovided by the Object class do not provide meaningful results for arrays. hashCode() returns the array\u2019s \"identity hash\ncode\", and toString() returns nearly the same value. Neither method\u2019s output reflects the array\u2019s contents."
    },
    {
        "id": 146,
        "title": "Collections should not be passed as arguments to their own methods",
        "description": "Passing a collection as an argument to the collection\u2019s own method is either an error - some other argument was intended - or simply nonsensical\ncode.\nFurther, because some methods require that the argument remain unmodified during the execution, passing a collection to itself can result in\nundefined behavior.\nNoncompliant code example\nList <Object> objs = new ArrayList<Object>();\nobjs.add(\"Hello\");\n\nobjs.add(objs); // Noncompliant; StackOverflowException if objs.hashCode() called\nobjs.addAll(objs); // Noncompliant; behavior undefined\nobjs.containsAll(objs); // Noncompliant; always true\nobjs.removeAll(objs); // Noncompliant; confusing. Use clear() instead\nobjs.retainAll(objs); // Noncompliant; NOOP"
    },
    {
        "id": 147,
        "title": "\"BigDecimal(double)\" should not be used",
        "description": "The BigDecimal is used to represents immutable, arbitrary-precision signed decimal numbers.\nDifferently from the BigDecimal , the double primitive type and the Double type have limited precision due to\nthe use of double-precision 64-bit IEEE 754 floating point. Because of floating point imprecision, the BigDecimal(double) constructor can\nbe somewhat unpredictable.\nFor example writing new BigDecimal(0.1) doesn\u2019t create a BigDecimal which is exactly equal to 0.1, but it is equal to\n0.1000000000000000055511151231257827021181583404541015625. This is because 0.1 cannot be represented exactly as a double (or, for that matter, as a\nbinary fraction of any finite length)."
    },
    {
        "id": 148,
        "title": "Invalid \"Date\" values should not be used",
        "description": "Whether the valid value ranges for Date fields start with 0 or 1 varies by field. For instance, month starts at 0, and day of month\nstarts at 1. Enter a date value that goes past the end of the valid range, and the date will roll without error or exception. For instance, enter 12\nfor month, and you\u2019ll get January of the following year.\nThis rule checks for bad values used in conjunction with java.util.Date , java.sql.Date , and java.util.Calendar . Specifically, values outside of the valid ranges:\nmonth\n0-11\ndate (day)\n0-31\nhour\n0-23\nminute\n0-60\nsecond\n0-61\nNote that this rule does not check for invalid leap years, leap seconds (second = 61), or invalid uses of the 31st day of the month.\nNoncompliant code example\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(12);  // Noncompliant; rolls d into the next year\n\nCalendar c = new GregorianCalendar(2014, 12, 25);  // Noncompliant\nif (c.get(Calendar.MONTH) == 12) {  // Noncompliant; invalid comparison\n  // ...\n}\nCompliant solution\nDate d = new Date();\nd.setDate(25);\nd.setYear(2014);\nd.setMonth(11);\n\nCalendar c = new Gregorian Calendar(2014, 11, 25);\nif (c.get(Calendar.MONTH) == 11) {\n  // ...\n}"
    },
    {
        "id": 149,
        "title": "Reflection should not be used to check non-runtime annotations",
        "description": "Denoted by the \"@\" symbol, annotations are metadata that can be added to classes, methods, and variables for various purposes such as\ndocumentation, code analysis, and runtime processing.\nAnnotations have retention policies that determine in which context they are retained and available for use. There are three retention policies for\nannotations:\nRetentionPolicy.SOURCE - Annotations are only available during compilation and code analysis. They are not included in the\n  compiled class file and are not available at runtime. E.G. @Override , @SuppressWarnings RetentionPolicy.CLASS - Annotations are included in the compiled class file providing information to the compiler, but they are\n  not retained by the JVM at runtime. This is the default retention policy. E.G. @PreviewFeature RetentionPolicy.RUNTIME - Annotations are included in the compiled class file and available at runtime. They can be accessed and\n  used by the program through reflection. E.G. @FunctionalInterface , @Deprecated\nRetentionPolicy.SOURCE - Annotations are only available during compilation and code analysis. They are not included in the\n  compiled class file and are not available at runtime. E.G. @Override , @SuppressWarnings\nRetentionPolicy.CLASS - Annotations are included in the compiled class file providing information to the compiler, but they are\n  not retained by the JVM at runtime. This is the default retention policy. E.G. @PreviewFeature\nRetentionPolicy.RUNTIME - Annotations are included in the compiled class file and available at runtime. They can be accessed and\n  used by the program through reflection. E.G. @FunctionalInterface , @Deprecated\nIt is important to understand that only annotations having the RUNTIME retention policy can be accessed at runtime using reflection.\nFor example, the following if condition is true when the method argument is the java.util.function.Function class:\nvoid execute(Class<?> cls) {\n  if (cls.isAnnotationPresent(FunctionalInterface.class)) {\n    // ...\n  }\n}\nTherefore, it is an issue to use reflection in combination with annotations with the SOURCE or CLASS retention policy\nbecause they are not present at runtime. For example, in the JVM source code, the hashCode() method of the Integer class has\nthe @Override annotation. However, the following if condition will always be false even if the method argument is the Integer#hashCode() method because @Override has the SOURCE retention policy:\nvoid execute(Method method) {\n  if (method.isAnnotationPresent(Override.class)) { // Noncompliant, if condition will always be false because\n                                                    // @Override is declared with @Retention(RetentionPolicy.SOURCE)\n    // ...\n  }\n}\nThis rule detects improper reflective access on annotations having the SOURCE or CLASS retention policy."
    },
    {
        "id": 150,
        "title": "\"equals(Object obj)\" should test the argument's type",
        "description": "The Object#equals(Object obj) method is used to compare two objects to see if they are equal.\nThe obj parameter\u2019s type is Object , this means that an object of any type can be passed as a parameter to this\nmethod.\nAny class overriding Object#equals(Object obj) should respect this contract, accept any object as an argument, and return false when the argument\u2019s type differs from the expected type. The obj parameter\u2019s type can be checked using instanceof or by comparing the getClass() value:\n@Override\npublic boolean equals(Object obj) {\n  // ...\n  if (this.getClass() != obj.getClass()) {\n    return false;\n  }\n  // ...\n}\nHowever, it is an issue to assume that the equals method will only be used to compare objects of the same type. Casting the obj parameter without a prior test will throw a ClassCastException instead of returning false.\npublic class MyClass {\n  @Override\n  public boolean equals(Object obj) {\n    MyClass that = (MyClass) obj; // may throw a ClassCastException\n    // ...\n  }\n  // ...\n}\nThis rule raises an issue when obj parameter\u2019s type has not been tested before a cast operation."
    },
    {
        "id": 151,
        "title": "Resources should be closed",
        "description": "Connections, streams, files, and other classes that implement the Closeable interface or its super-interface, AutoCloseable , needs to be closed after use. Further, that close call must be made in a finally block otherwise\nan exception could keep the call from being made. Preferably, when class implements AutoCloseable , resource should be created using\n\"try-with-resources\" pattern and will be closed automatically.\nFailure to properly close resources will result in a resource leak which could bring first the application and then perhaps the box the application\nis on to their knees.\nNoncompliant code example\nprivate void readTheFile() throws IOException {\n  Path path = Paths.get(this.fileName);\n  BufferedReader reader = Files.newBufferedReader(path, this.charset);\n  // ...\n  reader.close();  // Noncompliant\n  // ...\n  Files.lines(\"input.txt\").forEach(System.out::println); // Noncompliant: The stream needs to be closed\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    for (String property : propertyList) {\n      stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();  // Multiple streams were opened. Only the last is closed.\n  }\n}\nCompliant solution\nprivate void readTheFile(String fileName) throws IOException {\n    Path path = Paths.get(fileName);\n    try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {\n      reader.readLine();\n      // ...\n    }\n    // ..\n    try (Stream<String> input = Files.lines(\"input.txt\"))  {\n      input.forEach(System.out::println);\n    }\n}\n\nprivate void doSomething() {\n  OutputStream stream = null;\n  try {\n    stream = new FileOutputStream(\"myfile.txt\");\n    for (String property : propertyList) {\n      // ...\n    }\n  } catch (Exception e) {\n    // ...\n  } finally {\n    stream.close();\n  }\n}\nExceptions\nInstances of the following classes are ignored by this rule because close has no effect:\njava.io.ByteArrayOutputStream java.io.ByteArrayInputStream java.io.CharArrayReader java.io.CharArrayWriter java.io.StringReader java.io.StringWriter\njava.io.ByteArrayOutputStream\njava.io.ByteArrayInputStream\njava.io.CharArrayReader\njava.io.CharArrayWriter\njava.io.StringReader\njava.io.StringWriter\nJava 7 introduced the try-with-resources statement, which implicitly closes Closeables . All resources opened in a try-with-resources\nstatement are ignored by this rule.\ntry (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n  //...\n}\ncatch ( ... ) {\n  //...\n}"
    },
    {
        "id": 152,
        "title": "\"Serializable\" inner classes of non-serializable outer classes should be \"static\"",
        "description": "Non-static inner classes contain a reference to an instance of the outer class. Hence, serializing a non-static inner class will result in an\nattempt at serializing the outer class as well. If the outer class is not serializable, serialization will fail, resulting in a runtime error.\nMaking the inner class static (i.e., \"nested\") avoids this problem, as no reference to an instance of the outer class is required.\nSerializing the inner class can be done independently of the outer class. Hence, inner classes implementing Serializable should be static if the outer class does not implement Serializable .\nBe aware of the semantic differences between an inner class and a nested one:\nan inner class can only be instantiated within the context of an instance of the outer class. a nested ( static ) class can be instantiated independently of the outer class.\nan inner class can only be instantiated within the context of an instance of the outer class.\na nested ( static ) class can be instantiated independently of the outer class."
    },
    {
        "id": 153,
        "title": "Custom serialization methods should have required signatures",
        "description": "Java offers a built-in serialization mechanism for classes that implement the Serializable interface. The developer can either rely on\nJava\u2019s default serialization and deserialization logic or implement custom methods for these tasks. The JVM will use methods such as readObject and writeObject to execute custom behavior. This only works, however, if these methods match exactly the expected\nsignatures. If they do not, the JVM will fall back to the default logic, resulting in unexpected behavior at runtime, while the developer believes\nthat the default logic has been overidden.\nThis rule raises an issue if an implementation of writeObject , readObject , readObjectNoData , writeReplace , or readResolve has an incorrect access modifier, return type, or is not static when it should be (and\nvice-versa)."
    },
    {
        "id": 154,
        "title": "\"Externalizable\" classes should have no-arguments constructors",
        "description": "A class that implements java.io.Externalizable is a class that provides a way to customize the serialization and deserialization,\nallowing greater control over how the object\u2019s state is written or read.\nThe first step of the deserialization process is to call the class' no-argument constructor before the readExternal(ObjectInput in) method.\nAn implicit default no-argument constructor exists on a class when no constructor is explicitly defined within the class. But this implicit\nconstructor does not exist when any constructor is explicitly defined, and in this case, we should always ensure that one of the constructors has\nno-argument.\nIt is an issue if the implicit or explicit no-argument constructor is missing or not public, because the deserialization will fail and throw an InvalidClassException: no valid constructor. ."
    },
    {
        "id": 155,
        "title": "The non-serializable super class of a \"Serializable\" class should have a no-argument constructor",
        "description": "Java serialization is the conversion from objects to byte streams for storage or transmission. And later, java deserialization is the reverse\nconversion, it reconstructs objects from byte streams.\nTo make a java class serializable, this class should implement the java.io.Serializable interface directly or through its\ninheritance.\nimport java.io.Serializable;\n\npublic class NonSerializableClass {\n}\n\npublic class SerializableClass implements Serializable {\n}\n\npublic class OtherSerializableClass extends SerializableClass {\n  // is also serializable because it is a subtype of Serializable\n}\nGiven a serializable class, it is important to note that not all its superclasses are serializable. Eventually, its superclasses stop implementing java.io.Serializable . It could be at the end, once reaching the java.lang.Object class, or before.\nThis is important because the serialization/deserialization runs through the class hierarchy of an object to decide which object fields to write or\nread, and applies two different logics:\nWhen the class is serializable: Serialization saves the class reference and the object fields of this class. Deserialization instantiates a new object of this class without using a constructor, and restores the object fields of this class. When the class is not serializable: Serialization only saves the class reference and ignores the object fields of this class. Deserialization instantiates a new object of this class using the no-argument constructor and does not restore the object\n      fields of this class.\nWhen the class is serializable: Serialization saves the class reference and the object fields of this class. Deserialization instantiates a new object of this class without using a constructor, and restores the object fields of this class.\nSerialization saves the class reference and the object fields of this class. Deserialization instantiates a new object of this class without using a constructor, and restores the object fields of this class.\nSerialization saves the class reference and the object fields of this class.\nDeserialization instantiates a new object of this class without using a constructor, and restores the object fields of this class.\nWhen the class is not serializable: Serialization only saves the class reference and ignores the object fields of this class. Deserialization instantiates a new object of this class using the no-argument constructor and does not restore the object\n      fields of this class.\nSerialization only saves the class reference and ignores the object fields of this class. Deserialization instantiates a new object of this class using the no-argument constructor and does not restore the object\n      fields of this class.\nSerialization only saves the class reference and ignores the object fields of this class.\nDeserialization instantiates a new object of this class using the no-argument constructor and does not restore the object\n      fields of this class.\nSo developers should pay particular attention to the non-serializable classes in the class hierarchy, because the presence of an implicit or\nexplicit no-argument constructor is required in those classes.\nThis is an example of mandatory no-argument constructors in the hierarchy of SerializableClass :\npublic class NonSerializableClassWithoutConstructor {\n  // after deserialization, \"field1\" will always be set to 42\n  private int field1 = 42;\n\n  // this non-serializable class has an implicit no-argument constructor\n}\n\npublic class NonSerializableClass extends NonSerializableClassWithoutConstructor {\n  // after deserialization, \"field2\" will always be set to 12 by the no-argument constructor\n  private int field2;\n\n  // this non-serializable class has an explicit no-argument constructor\n  public NonSerializableClass() {\n    field2 = 12;\n  }\n\n  public NonSerializableClass(int field2) {\n    this.field2 = field2;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n  // after deserialization, \"field3\" will have the previously serialized value.\n  private int field3;\n\n  // deserialization does not use declared constructors\n  public SerializableClass(int field3) {\n    super(field3 * 2);\n    this.field3 = field3;\n  }\n}\nUnfortunately, there is no compilation error when a class implements java.io.Serializable and extends a non-serializable superclass\nwithout a no-argument constructor. This is an issue because, at runtime, deserialization will fail to find the required constructor.\nFor example, deserialization of an instance of the following SerializableClass class, throws an InvalidClassException: no valid\nconstructor .\npublic class NonSerializableClass {\n  private int field;\n  // this class can not be deserialized because it does not have any implicit or explicit no-argument constructor\n  public NonSerializableClass(int field) {\n    this.field = field;\n  }\n}\n\npublic class SerializableClass extends NonSerializableClass implements Serializable {\n}\nThis rule checks in the hierarchy of serializable classes and reports an issue when a non-serializable superclass does not have the required\nno-argument constructor which will produce a runtime error."
    },
    {
        "id": 156,
        "title": "Classes should not be compared by name",
        "description": "There is no requirement that class names be unique, only that they be unique within a package. Therefore trying to determine an object\u2019s type based\non its class name is an exercise fraught with danger. One of those dangers is that a malicious user will send objects of the same name as the trusted\nclass and thereby gain trusted access.\nInstead, the instanceof operator or the Class.isAssignableFrom() method should be used to check the object\u2019s underlying\ntype.\nNoncompliant code example\npackage computer;\nclass Pear extends Laptop { ... }\n\npackage food;\nclass Pear extends Fruit { ... }\n\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (\"Pear\".equals(item.getClass().getSimpleName())) {  // Noncompliant\n      return true;  // Results in throwing away week-old computers\n    }\n    return false;\n  }\n\n  public boolean isList(Class<T> valueClass) {\n    if (List.class.getName().equals(valueClass.getName())) {  // Noncompliant\n      return true;\n    }\n    return false;\n  }\n}\nCompliant solution\nclass Store {\n\n  public boolean hasSellByDate(Object item) {\n    if (item instanceof food.Pear) {\n      return true;\n    }\n    return false;\n  }\n\n  public boolean isList(Class<T> valueClass) {\n    if (valueClass.isAssignableFrom(List.class)) {\n      return true;\n    }\n    return false;\n  }\n}"
    },
    {
        "id": 157,
        "title": "Related \"if/else if\" statements should not have the same condition",
        "description": "A chain of if / else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to true .\nTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it\u2019s simply dead code and\nat worst, it\u2019s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\nNoncompliant code example\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 1)  // Noncompliant\n  moveWindowToTheBackground();\n}\nCompliant solution\nif (param == 1)\n  openWindow();\nelse if (param == 2)\n  closeWindow();\nelse if (param == 3)\n  moveWindowToTheBackground();\n}"
    },
    {
        "id": 158,
        "title": "Synchronization should not be done on instances of value-based classes",
        "description": "In Java, value-based classes are those for which instances are final and immutable, like String , Integer and so on, and\ntheir identity relies on their value and not their reference. When a variable of one of these types is instantiated, the JVM caches its value, and the\nvariable is just a reference to that value. For example, multiple String variables with the same value \"Hello world!\" will refer to the\nsame cached string literal in memory.\nThe synchronized keyword tells the JVM to only allow the execution of the code contained in the following block to one Thread at a time. This mechanism relies on the identity of the object that is being synchronized between threads, to prevent that if\nobject X is locked, it will still be possible to lock another object Y.\nIt means that the JVM will fail to correctly synchronize threads on instances of the aforementioned value-based classes, for instance:\n// These variables \"a\" and \"b\" will effectively reference the same object in memory\nInteger a = 0;\nInteger b = 0;\n\n// This means that in the following code, the JVM could try to lock and execute\n// on the variable \"a\" because \"b\" was notified to be released, as the two Integer variables\n// are the same object to the JVM\nvoid syncMethod(int x) {\n    synchronized (a) {\n        if (a == x) {\n        // ... do something here\n        }\n    }\n    synchronized (b) {\n        if (b == x) {\n        // ... do something else\n        }\n    }\n}\nThis behavior can cause unrelated threads to deadlock with unclear stacktraces.\nWithin the JDK, types which should not be used for synchronization include:\nString literals Primitive wrapper classes in java.lang (such as Boolean with Boolean.FALSE and Boolean.TRUE ) The class java.lang.Runtime.Version The Optional* classes in java.util : Optional , OptionalInt , OptionalLong , and OptionalDouble Various classes in the java.time API: Instant , LocalDate , LocalTime , LocalDateTime , ZonedDateTime , ZoneId , OffsetTime , OffsetDateTime , ZoneOffset , Duration , Period , Year , YearMonth , and MonthDay Various classes in the java.time.chrono API: MinguoDate , HijrahDate , JapaneseDate , and ThaiBuddhistDate The interface java.lang.ProcessHandle and its implementation classes The implementation classes of the collection factories in java.util : List.of , List.copyOf , Set.of , Set.copyOf , Map.of , Map.copyOf , Map.ofEntries , and Map.entry .\nString literals\nPrimitive wrapper classes in java.lang (such as Boolean with Boolean.FALSE and Boolean.TRUE )\nThe class java.lang.Runtime.Version\nThe Optional* classes in java.util : Optional , OptionalInt , OptionalLong , and OptionalDouble\nVarious classes in the java.time API: Instant , LocalDate , LocalTime , LocalDateTime , ZonedDateTime , ZoneId , OffsetTime , OffsetDateTime , ZoneOffset , Duration , Period , Year , YearMonth , and MonthDay\nVarious classes in the java.time.chrono API: MinguoDate , HijrahDate , JapaneseDate , and ThaiBuddhistDate\nThe interface java.lang.ProcessHandle and its implementation classes\nThe implementation classes of the collection factories in java.util : List.of , List.copyOf , Set.of , Set.copyOf , Map.of , Map.copyOf , Map.ofEntries , and Map.entry ."
    },
    {
        "id": 159,
        "title": "\"Iterator.hasNext()\" should not call \"Iterator.next()\"",
        "description": "Calling Iterator.hasNext() is not supposed to have any side effects and hence should not change the iterator\u2019s state. Iterator.next() advances the iterator by one item. So calling it inside Iterator.hasNext() breaks the hasNext() contract and will lead to unexpected behavior in production."
    },
    {
        "id": 160,
        "title": "Identical expressions should not be used on both sides of a binary operator",
        "description": "Using the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of bitwise operators and most binary mathematical operators,\nhaving the same value on both sides of an operator yields predictable results and should be simplified as well.\nNoncompliant code example\nif ( a == a ) { // always true\n  doZ();\n}\nif ( a != a ) { // always false\n  doY();\n}\nif ( a == b && a == b ) { // if the first one is true, the second one is too\n  doX();\n}\nif ( a == b || a == b ) { // if the first one is true, the second one is too\n  doW();\n}\n\nint j = 5 / 5; //always 1\nint k = 5 - 5; //always 0\n\nc.equals(c); //always true\nExceptions\nThis rule ignores * , + , and = . The specific case of testing a floating point value against itself is a valid test for NaN and is therefore ignored. Similarly, left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.\nThis rule ignores * , + , and = .\nThe specific case of testing a floating point value against itself is a valid test for NaN and is therefore ignored.\nSimilarly, left-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.\nfloat f;\nif(f != f) { //test for NaN value\n  System.out.println(\"f is NaN\");\n}\n\nint i = 1 << 1; // Compliant\nint j = a << a; // Noncompliant"
    },
    {
        "id": 161,
        "title": "Loops with at most one iteration should be refactored",
        "description": "A loop with at most one iteration is equivalent to an if statement. This can confuse developers and make the code less readable since\nloops are not meant to replace if statements.\nIf the intention was to conditionally execute the block only once, an if statement should be used instead. Otherwise, the loop should\nbe fixed so the loop block can be executed multiple times.\nA loop statement with at most one iteration can happen when a statement that unconditionally transfers control, such as a jump or throw statement,\nis misplaced inside the loop block.\nThis rule arises when the following statements are misplaced:\nbreak return throw\nbreak\nreturn\nthrow"
    },
    {
        "id": 162,
        "title": "Variables should not be self-assigned",
        "description": "There is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\nNoncompliant code example\npublic void setName(String name) {\n  name = name;\n}\nCompliant solution\npublic void setName(String name) {\n  this.name = name;\n}"
    },
    {
        "id": 163,
        "title": "\"StringBuilder\" and \"StringBuffer\" should not be instantiated with a character",
        "description": "When a developer uses the StringBuilder or StringBuffer constructor with a single character as an argument, the likely\nintention is to create an instance with the character as the initial string value.\nHowever, this is not what happens because of the absence of a dedicated StringBuilder(char) or StringBuffer(char) constructor. Instead, StringBuilder(int) or StringBuffer(int) is invoked, which results in an instance with the provided int value as the initial capacity of the StringBuilder or StringBuffer .\nThe reason behind this behavior lies in the automatic widening of char expressions to int when required. Consequently,\nthe UTF-16 code point value of the character (for example, 65 for the character 'A' ) is interpreted as an int to specify the initial capacity."
    },
    {
        "id": 164,
        "title": "Floating point numbers should not be tested for equality",
        "description": "Floating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a float or a double through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\nEven simple floating point assignments are not simple:\nfloat f = 0.1; // 0.100000001490116119384765625\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n(Results will vary based on compiler and compiler settings);\nTherefore, the use of the equality ( == ) and inequality ( != ) operators on float or double values\nis almost always an error. Instead the best course is to avoid floating point comparisons altogether. When that is not possible, you should consider\nusing one of Java\u2019s float-handling Numbers such as BigDecimal which can properly handle floating point comparisons. A third\noption is to look not for equality but for whether the value is close enough. I.e. compare the absolute value of the difference between the stored\nvalue and the expected value against a margin of acceptable error. Note that this does not cover all cases ( NaN and Infinity for instance).\nThis rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.\nNoncompliant code example\nfloat myNumber = 3.146;\nif ( myNumber == 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\nif ( myNumber != 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be true\n  // ...\n}\n\nif (myNumber < 4 || myNumber > 4) { // Noncompliant; indirect inequality test\n  // ...\n}\n\nfloat zeroFloat = 0.0f;\nif (zeroFloat == 0) {  // Noncompliant. Computations may end up with a value close but not equal to zero.\n}\nExceptions\nSince NaN is not equal to itself, the specific case of testing a floating point value against itself is a valid test for NaN and is therefore ignored. Though using Double.isNaN method should be preferred instead, as intent is more explicit.\nfloat f;\ndouble d;\nif(f != f) { // Compliant; test for NaN value\n  System.out.println(\"f is NaN\");\n} else if (f != d) { // Noncompliant\n  // ...\n}"
    },
    {
        "id": 165,
        "title": "Method parameters, caught exceptions and foreach variables' initial values should not be ignored",
        "description": "While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug.\nInstead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final , then at least read\nbefore reassignment.\nNoncompliant code example\npublic void doTheThing(String str, int i, List<String> strings) {\n  str = Integer.toString(i); // Noncompliant\n\n  for (String s : strings) {\n    s = \"hello world\"; // Noncompliant\n  }\n}"
    },
    {
        "id": 166,
        "title": "Methods should not be named \"tostring\", \"hashcode\" or \"equal\"",
        "description": "Due to the similar name with the methods Object.toString , Object.hashCode and Object.equals , there is a\nsignificant likelihood that a developer intended to override one of these methods but made a spelling error.\nEven if no such error exists and the naming was done on purpose, these method names can be misleading. Readers might not notice the difference, or\nif they do, they may falsely assume that the developer made a mistake."
    },
    {
        "id": 167,
        "title": "\"Thread.run()\" should not be called directly",
        "description": "The likely intention of a user calling Thread.run() is to start the execution of code within a new thread. This, however, is not what\nhappens when this method is called.\nThe purpose of Thread.run() is to provide a method that users can overwrite to specify the code to be executed. The actual thread is\nthen started by calling Thread.start() . When Thread.run() is called directly, it will be executed as a regular method within\nthe current thread."
    },
    {
        "id": 168,
        "title": "\"equals(Object obj)\" and \"hashCode()\" should be overridden in pairs",
        "description": "According to the Java Language Specification, there is a contract between equals(Object) and hashCode() :\nIf two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two\n  objects must produce the same integer result.\nIt is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results.\nHowever, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of\n  hashtables.\nIn order to comply with this contract, those methods should be either both inherited, or both overridden."
    },
    {
        "id": 169,
        "title": "\"equals\" method overrides should accept \"Object\" parameters",
        "description": "In Java, the Object.equals() method is used for object comparison, and it is typically overridden in classes to provide a custom\nequality check based on your criteria for equality.\nThe default implementation of equals() provided by the Object class compares the memory references of the two objects,\nthat means it checks if the objects are actually the same instance in memory.\nThe \"equals\" as a method name should be used exclusively to override Object.equals(Object) to prevent confusion.\nIt is important to note that when you override equals() , you should also override the hashCode() method to maintain the\ncontract between equals() and hashCode() ."
    },
    {
        "id": 170,
        "title": "The signature of \"finalize()\" should match that of \"Object.finalize()\"",
        "description": "Object.finalize() is called by the Garbage Collector at some point after the object becomes unreferenced.\nIn general, overloading Object.finalize() is a bad idea because:\nThe overload may not be called by the Garbage Collector. Users are not expected to call Object.finalize() and will get confused.\nThe overload may not be called by the Garbage Collector.\nUsers are not expected to call Object.finalize() and will get confused.\nBut beyond that it\u2019s a terrible idea to name a method \"finalize\" if it doesn\u2019t actually override Object.finalize() .\nNoncompliant code example\npublic int finalize(int someParameter) {        // Noncompliant\n  /* ... */\n}\nCompliant solution\npublic int someBetterName(int someParameter) {  // Compliant\n  /* ... */\n}"
    },
    {
        "id": 171,
        "title": "Jump statements should not occur in \"finally\" blocks",
        "description": "Using return , break , throw , and so on from a finally block suppresses the propagation of any\nunhandled Throwable which was thrown in the try or catch block.\nThis rule raises an issue when a jump statement ( break , continue , return , throw , and goto ) would force control flow to leave a finally block.\nNoncompliant code example\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");   // incorrect \"OK\" message is printed\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // this message is not shown\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i < 10; i ++) {\n      //...\n      if (q == i) {\n        break; // ignored\n      }\n    }\n\n    /* ... */\n    return;      // Noncompliant - prevents the RuntimeException from being propagated\n  }\n}\nCompliant solution\npublic static void main(String[] args) {\n  try {\n    doSomethingWhichThrowsException();\n    System.out.println(\"OK\");\n  } catch (RuntimeException e) {\n    System.out.println(\"ERROR\");  // \"ERROR\" is printed as expected\n  }\n}\n\npublic static void doSomethingWhichThrowsException() {\n  try {\n    throw new RuntimeException();\n  } finally {\n    for (int i = 0; i < 10; i ++) {\n      //...\n      if (q == i) {\n        break; // ignored\n      }\n    }\n\n    /* ... */\n  }\n}"
    },
    {
        "id": 172,
        "title": "\"super.finalize()\" should be called at the end of \"Object.finalize()\" implementations",
        "description": "Overriding the Object.finalize() method must be done with caution to dispose some system resources.\nCalling the super.finalize() at the end of this method implementation is highly recommended in case parent implementations must also\ndispose some system resources.\nNoncompliant code example\nprotected void finalize() {   // Noncompliant; no call to super.finalize();\n  releaseSomeResources();\n}\n\nprotected void finalize() {\n  super.finalize();  // Noncompliant; this call should come last\n  releaseSomeResources();\n}\nCompliant solution\nprotected void finalize() {\n  releaseSomeResources();\n  super.finalize();\n}"
    },
    {
        "id": 173,
        "title": "The \"Object.finalize()\" method should not be called",
        "description": "Before it reclaims storage from an object that is no longer referenced, the garbage collector calls finalize() on the object.\nThis is a good time to release resources held by the object.\nBecause the general contract is that the finalize method should only be called once per object, calling this method explicitly is\nmisleading and does not respect this contract.\nWhat is the potential impact?\nAn explicit call to an object\u2019s finalize method will perform operations that most likely were supposed to be performed only when the object was not\nreferenced anymore by any thread.\nSince it is an acceptable practice to override the finalize method in any subclass of Object , by invoking it explicitly, we will run\ncode that was designed to only be ran at a different time.\nNoncompliant code example\npublic void dispose() throws Throwable {\n  this.finalize();                       // Noncompliant\n}"
    }
]